<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>写码笔记</title>
  
  <subtitle>duqutao@gmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://eggggger.xyz/"/>
  <updated>2018-03-12T16:10:36.000Z</updated>
  <id>http://eggggger.xyz/</id>
  
  <author>
    <name>yadan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【译】Node.js Best Practices</title>
    <link href="http://eggggger.xyz/2017/11/19/nodebestpractices/"/>
    <id>http://eggggger.xyz/2017/11/19/nodebestpractices/</id>
    <published>2017-11-19T12:32:12.000Z</published>
    <updated>2018-03-12T16:10:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/i0natan/nodebestpractices" target="_blank" rel="noopener">原文链接</a></p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是一个简读版，没有翻译原文 <code>Read More</code> 里的内容，不过比较重要的内容我都将它提取出来了。另外，下文 <code>PS:</code> 开头的内容是我个人的一些补充，并非出自原文。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol><li><a href="#1-项目结构">项目结构</a>   </li><li><a href="#2-错误处理">错误处理</a>   </li><li><a href="#3-代码风格">代码风格</a>  </li><li><a href="#4-测试和总体质量">测试和总体质量</a>  </li><li><a href="#5-投入生产使用">投入生产使用</a>  </li><li><a href="#6-安全">安全 - 即将发布</a>  </li><li><a href="#7-性能">性能 - 即将发布</a></li></ol><h1 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1. 项目结构"></a><code>1. 项目结构</code></h1><h2 id="1-1-组件化结构"><a href="#1-1-组件化结构" class="headerlink" title="1.1 组件化结构"></a>1.1 组件化结构</h2><p> <strong>TL;DR:</strong>  最坑爹的软件缺陷就是维护一个包含成百上千依赖关系的超大代码库，这样的大怪物严重的拖慢了新功能的开发速度。因此，可以将你的代码拆分成组件，每一个组件都有自己的目录或者专门的代码库，并且确保每一个组件都小而简单。</p><p><strong>Otherwise:</strong> 当新功能的开发者很难弄明白代码变动所会造成的影响并且害怕打破其他组件的依赖时 —— 部署变得更慢并且风险更大。这时候想要再进行扩展十分艰难，是时候考虑拆分业务逻辑了。</p><p><strong>PS:</strong> 下面是 <code>Read More</code> 里给的例子，不过个人觉得项目结构是一个见仁见智的东西，MVC 及其一些变种不管在 <code>SOA</code> 还是 <code>微服务</code> 下都有广泛的应用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Good: 按组件划分</span><br><span class="line">.</span><br><span class="line">├── componets</span><br><span class="line">│   ├── orders</span><br><span class="line">│   ├── products</span><br><span class="line">│   └── users</span><br><span class="line">└── libraries</span><br><span class="line"></span><br><span class="line">Bad: 按技术角色划分</span><br><span class="line">.</span><br><span class="line">├── controllers</span><br><span class="line">├── models</span><br><span class="line">├── tests</span><br><span class="line">├── utils</span><br><span class="line">└── views</span><br></pre></td></tr></table></figure><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/projectstructre/breakintcomponents.md" target="_blank" rel="noopener"><strong>Read More: structure by components</strong></a></p><h2 id="1-2-将你的-app-分层，限制-Express-的边界"><a href="#1-2-将你的-app-分层，限制-Express-的边界" class="headerlink" title="1.2 将你的 app 分层，限制 Express 的边界"></a>1.2 将你的 app 分层，限制 Express 的边界</h2><p><strong>TL;DR:</strong> 每个组件都应该包含分层 —— 一个专门用于 Web，业务逻辑和数据访问的对象。它不仅能有一个清晰的 <a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB" target="_blank" rel="noopener">关注点分离</a>，还能大大简化 <code>Mock</code> 和 <code>测试</code> 系统。虽然这是一种非常常见的模式，但是 API 开发者还是倾向于把 Web 层对象 (Express req, res) 传递到业务逻辑和数据层 —— 这使得你的程序依赖于 Express，并且只能通过 Express 访问。</p><p><strong>Otherwise:</strong> 将 Web 层对象与其他层混合的应用程序将无法通过测试代码，Cron 任务和其他非Express 代码进行调用。</p><p><strong>PS:</strong> 不仅仅是 <code>Express</code>，像 <code>Koa</code>、<code>Hapi</code>甚至 <code>HTTP Module</code> 的 context 其实都应该做好隔离。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/projectstructre/createlayers.md" target="_blank" rel="noopener"><strong>Read More: layer your app</strong></a></p><h2 id="1-3-将通用功能打成-NPM-包"><a href="#1-3-将通用功能打成-NPM-包" class="headerlink" title="1.3 将通用功能打成 NPM 包"></a>1.3 将通用功能打成 NPM 包</h2><p><strong>TL;DR:</strong> 在大型应用程序中，像日志，加密之类的通用功能应该被单独封装成一个私有 NPM 包，这使得它们能在不同的项目中共享。</p><p><strong>Otherwise:</strong> 你不得不造一个发布和依赖的轮子。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/projectstructre/wraputilities.md" target="_blank" rel="noopener"><strong>Read More: Structure by feature</strong></a></p><h2 id="1-4-分离-Express-的-app-和-server"><a href="#1-4-分离-Express-的-app-和-server" class="headerlink" title="1.4 分离 Express 的 app 和 server"></a>1.4 分离 Express 的 app 和 server</h2><p><strong>TL;DR:</strong> 避免在一个巨大的文件中定义整个 <code>Express</code> 应用，将你的 <code>Express</code> 定义拆分成最少两个文件：API 声明（app.js）和 服务声明（WWW）。要获得更好的结构，请把你的 API 声明放在组件中。</p><p><strong>Otherwise:</strong> 你的 API 只能通过 HTTP 调用来进行测试（缓慢并且难以生成代码覆盖率报告）。或许在单个文件中维护数百行代码并不是什么难事 <img src="http://ozlrjyp17.bkt.clouddn.com/62e721e4gw1et02g5wksrj200k00k3y9.jpg" alt="">。</p><p><strong>PS:</strong> 一般可以把其拆成 app 和 server, server 结合命令行工具可以做一些启动时的配置。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/projectstructre/separateexpress.md" target="_blank" rel="noopener"><strong>Read More: separate Express ‘app’ and ‘server’</strong></a></p><h2 id="1-5-使用能读取环境变量，安全和分层级的配置"><a href="#1-5-使用能读取环境变量，安全和分层级的配置" class="headerlink" title="1.5 使用能读取环境变量，安全和分层级的配置"></a>1.5 使用能读取环境变量，安全和分层级的配置</h2><p><strong>TL;DR:</strong> 一个完善的配置设置应该确保：</p><ul><li>可以从文件和环境变量中读取键值</li><li>敏感内容保存在提交代码之外</li><li>配置是分层级的并且容易查找</li></ul><p>只有少数几个包符合以上条件，比如 <a href="https://github.com/dominictarr/rc" target="_blank" rel="noopener">rc</a>、 <a href="https://github.com/indexzero/nconf" target="_blank" rel="noopener">nconf</a> 和 <a href="https://github.com/lorenwest/node-config" target="_blank" rel="noopener">config</a>。</p><p><strong>Otherwise:</strong> 如果不能满足这些配置要求，将会使团队的开发陷入困境。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/projectstructre/configguide.md" target="_blank" rel="noopener"><strong>Read More: configuration best practices</strong></a></p><h1 id="2-错误处理"><a href="#2-错误处理" class="headerlink" title="2. 错误处理"></a><code>2. 错误处理</code></h1><h2 id="2-1-使用-Async-Await-或-Promises-进行异步错误处理"><a href="#2-1-使用-Async-Await-或-Promises-进行异步错误处理" class="headerlink" title="2.1 使用 Async-Await 或 Promises 进行异步错误处理"></a>2.1 使用 Async-Await 或 Promises 进行异步错误处理</h2><p><strong>TL;DR:</strong> 在回调中处理异步错误可能是最糟糕的方式。你能给你代码送的最好的礼物就是使用一个可靠的 <code>Promise</code> 库或者 <code>async-await</code> 作为回调方式的替代，这使得使用一些像 <code>try-catch</code> 一样更紧凑和更熟悉的语法成为可能。</p><p><strong>Otherwise:</strong> Node.JS 回调风格，<code>function(error, response)</code> 是一个让代码不可维护的好办法， 因为他使错误处理和正常代码相混合，过度嵌套以及十分蹩脚的编码方式。</p><p><strong>PS:</strong> Node 最让人诟病的地方之一就是回调，不过现在已经是 2017 年了😑</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/errorhandling/asyncerrorhandling.md" target="_blank" rel="noopener"><strong>Read More: avoiding callbacks</strong></a></p><h2 id="2-2-只使用内置的-Error-对象"><a href="#2-2-只使用内置的-Error-对象" class="headerlink" title="2.2 只使用内置的 Error 对象"></a>2.2 只使用内置的 Error 对象</h2><p><strong>TL;DR:</strong> 很多人使用字符串或一些自定义类型抛出错误 —— 这会使得错误处理逻辑和模块之间的互操作变得复杂。不管你是 <code>reject promise</code>、 <code>throw exception</code> 还是 <code>emit error</code> 只使用内置的 Error 对象可以增加一致性并且能防止错误信息的丢失。</p><p><strong>Otherwise:</strong> 当调用某个组件时，不能确定会返回哪些错误类型会让错误处理变得很困难。甚至更坏的情况下使用自定义错误类型会导致重要的错误信息丢失，比如 stack trace !</p><p><strong>PS:</strong> 字符串之类的自定义错误应该避免，但是派生自 Error 对象的子错误类型有时会使错误处理变得更加灵活和方便。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/errorhandling/useonlythebuiltinerror.md" target="_blank" rel="noopener"><strong>Read More: using the built-in error object</strong></a></p><h2 id="2-3-区分操作错误和程序员错误"><a href="#2-3-区分操作错误和程序员错误" class="headerlink" title="2.3 区分操作错误和程序员错误"></a>2.3 区分操作错误和程序员错误</h2><p><strong>TL;DR:</strong> </p><ul><li>操作错误（如 API 收到一个非法的输入）指的是错误影响完全已知并且可以被妥善处理的情况</li><li>程序员错误（如 试图读取一个未定义的变量）则是指未知的代码异常，这表明需要适当的重启程序了</li></ul><p><strong>Otherwise:</strong> 当出现错误时，你可能总是要重新启动应用程序，但是为什么仅仅因为一个次要且可以预测的操作错误就要让 ~5000 在线用户不能使用呢？反之，当一个未知的错误（程序员错误）发生时，保持应用程序不退出则可能会造成不可预测的问题。区分这两者可以在不同的情况下巧妙地采取一些处理方法。</p><p>  🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/errorhandling/operationalvsprogrammererror.md" target="_blank" rel="noopener"><strong>Read More: operational vs programmer error</strong></a></p><h2 id="2-4-集中处理错误，而不是在-Express-中间件中"><a href="#2-4-集中处理错误，而不是在-Express-中间件中" class="headerlink" title="2.4 集中处理错误，而不是在 Express 中间件中"></a>2.4 集中处理错误，而不是在 Express 中间件中</h2><p><strong>TL;DR:</strong> 错误处理逻辑，如向管理员发邮件和日志记录等应该封装在一个专用的对象里，所有端点（例如 <code>Express 中间件</code>，<code>cron jobs</code>，<code>单元测试</code>）在出现错误时可以调用。</p><p><strong>Otherwise:</strong> 不在一个地方处理错误将会导致代码重复，并且可能无法正确地处理错误。</p><p><strong>PS:</strong> 其实可以在上层 middleware 里对抛出的错误进行统一捕获，利用错误处理对象，对带 status 或者特定信息的错误进行专门的处理，没带的则可以统一处理并抛出 500 错误。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/errorhandling/centralizedhandling.md" target="_blank" rel="noopener"><strong>Read More: handling errors in a centralized place</strong></a></p><h2 id="2-5-使用-Swagger-文档描述-API-错误"><a href="#2-5-使用-Swagger-文档描述-API-错误" class="headerlink" title="2.5 使用 Swagger 文档描述 API 错误"></a>2.5 使用 Swagger 文档描述 API 错误</h2><p><strong>TL;DR:</strong> 让调用者知道 API 可能会返回哪些错误，以便他们可以在不崩溃的情况下处理这些问题。通常这可以使用 <code>Swagger</code> 之类的 REST API 文档工具完成。</p><p><strong>Otherwise:</strong> 一个 API 客户端可能会崩溃并重新启动，因为他收到了一个无法理解的错误。注意：你也可能是你自己的 API 的调用者（在微服务环境中非常典型）。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/errorhandling/documentingusingswagger.md" target="_blank" rel="noopener"><strong>Read More: documenting errors in Swagger</strong></a></p><h2 id="2-6-当一个未知的错误发生时，优雅的关闭进程"><a href="#2-6-当一个未知的错误发生时，优雅的关闭进程" class="headerlink" title="2.6 当一个未知的错误发生时，优雅的关闭进程"></a>2.6 当一个未知的错误发生时，优雅的关闭进程</h2><p><strong>TL;DR:</strong> 当发生未知错误时，不能确定应用程序的健康状况。通常的做法是建议使用像 <code>Forever</code> 或<code>PM2</code> 这样的进程管理工具来重新启动。</p><p><strong>Otherwise:</strong> 当遇到陌生的异常时，某个对象可能处于错误的状态（如 一个全局的事件触发器可能因为一些内部错误不再产生事件），所有依赖他的功能可能会失败或者表现异常。</p><p><strong>PS:</strong> 可以使用 <code>uncaughtException</code> 事件捕获异常并做一些错误追踪处理，但是最好不要强行 catch 住异常。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/errorhandling/shuttingtheprocess.md" target="_blank" rel="noopener"><strong>Read More: shutting the process</strong></a></p><h2 id="2-7-使用成熟的-logger-工具来增加错误可见性"><a href="#2-7-使用成熟的-logger-工具来增加错误可见性" class="headerlink" title="2.7 使用成熟的 logger 工具来增加错误可见性"></a>2.7 使用成熟的 logger 工具来增加错误可见性</h2><p><strong>TL;DR:</strong> 一套成熟的 <code>logger</code> 工具如 <a href="https://github.com/winstonjs/winston" target="_blank" rel="noopener">Winston</a>, <a href="https://github.com/trentm/node-bunyan" target="_blank" rel="noopener">Bunyan</a> 或者 <a href="https://github.com/log4js-node/log4js-node" target="_blank" rel="noopener">Log4J</a> 可以加快错误查找和分析的速度。所以忘掉 <code>console.log</code> 吧。</p><p><strong>Otherwise:</strong> 通过 <code>console.log</code> 浏览或者不借助查询工具和日志查看器手动的在杂乱的文件中查找错误或许会让你加班到很晚<img src="http://ozlrjyp17.bkt.clouddn.com/62e721e4gw1et02g5wksrj200k00k3y9.jpg" alt="">。</p><p><strong>PS:</strong> <code>logger</code> 工具配 <code>ELK/EFK</code> 是一个常见的解决方案</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/errorhandling/usematurelogger.md" target="_blank" rel="noopener"><strong>Read More: using a mature logger</strong></a></p><h2 id="2-8-用你最喜欢的测试框架测试错误流程"><a href="#2-8-用你最喜欢的测试框架测试错误流程" class="headerlink" title="2.8 用你最喜欢的测试框架测试错误流程"></a>2.8 用你最喜欢的测试框架测试错误流程</h2><p><strong>TL;DR:</strong> 无论是专业的自动化 QA 还是 普通的开发者手动测试 —— 确保你的代码不仅能满足正面情况，还能处理和返回合适的错误。像 <a href="https://github.com/mochajs/mocha" target="_blank" rel="noopener">Mocha</a> &amp; <a href="https://github.com/chaijs/chai" target="_blank" rel="noopener">chai</a> 可以轻松的处理这种情况。</p><p><strong>Otherwise:</strong> 如果不进行测试，无论是自动的还是手动的，你都不能依靠我们的代码来返回合合适合适合适合适适的错误。没有有意义的错误等于没有错误处理。</p><p><strong>PS:</strong> 有一堆工具如 <code>mocha</code>、<code>ava</code>、<code>jest</code>、<code>supertest</code>、<code>sinon</code> 等可以供你选择。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/errorhandling/testingerrorflows.md" target="_blank" rel="noopener"><strong>Read More: testing error flows</strong></a></p><h2 id="2-9-使用-APM-产品来发现错误和停机时间"><a href="#2-9-使用-APM-产品来发现错误和停机时间" class="headerlink" title="2.9 使用 APM 产品来发现错误和停机时间"></a>2.9 使用 APM 产品来发现错误和停机时间</h2><p><strong>TL;DR:</strong> 监控和性能产品（又称 APM）通过主动评估你的代码或 API 来突出显示错误，崩溃数据和你疏忽的性能差的部分 。</p><p><strong>Otherwise:</strong> 你可能会花很多精力去测量 API 的性能和停机时间，而且很可能你永远也不会察觉到哪些部分才是是真实环境下最慢的，以及他是如何影响用户体验的。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/errorhandling/apmproducts.md" target="_blank" rel="noopener"><strong>Read More: using APM products</strong></a></p><h2 id="2-10-捕获未处理的-promise-rejections"><a href="#2-10-捕获未处理的-promise-rejections" class="headerlink" title="2.10 捕获未处理的 promise rejections"></a>2.10 捕获未处理的 promise rejections</h2><p><strong>TL;DR:</strong> 任何 promise 内的异常都会被吞噬和丢弃，除非你没有忘记去处理他。即使你订阅了 <code>process.uncaughtException</code>也没用! 可以注册事件到 <code>process.unhandledRejection</code> 来避免。</p><p><strong>Otherwise:</strong> 你的错误将被吞噬不会留下痕迹，你完全不必担心<img src="http://ozlrjyp17.bkt.clouddn.com/62e721e4gw1et02g5wksrj200k00k3y9.jpg" alt="">。</p><p><strong>PS:</strong> 一般像 <code>koa</code> 之类的框架，可以在内部进行错误捕获和处理。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/errorhandling/catchunhandledpromiserejection.md" target="_blank" rel="noopener"><strong>Read More: catching unhandled promise rejection</strong></a></p><h2 id="2-11-快速失败，使用专用库来校验参数"><a href="#2-11-快速失败，使用专用库来校验参数" class="headerlink" title="2.11 快速失败，使用专用库来校验参数"></a>2.11 快速失败，使用专用库来校验参数</h2><p><strong>TL;DR:</strong> 断言 API 输入，以避免在后面难以跟踪的恶心错误。校验代码通常很繁琐，除非使用像 <a href="https://github.com/hapijs/joi" target="_blank" rel="noopener">Joi</a> 这样的非常酷的辅助库。</p><p><strong>Otherwise:</strong> 你想一下 —— 你的函数需要一个数字参数 <code>Discount</code>，但是调用者忘记传了。稍后你在你的代码判断 <code>if Discount !== 0</code>，那么它将会允许用户使用折扣。OMG，你看到了吗？这是一个讨厌的bug。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/errorhandling/failfast.md" target="_blank" rel="noopener"><strong>Read More: failing fast</strong></a></p><h1 id="3-代码风格"><a href="#3-代码风格" class="headerlink" title="3 代码风格"></a><code>3 代码风格</code></h1><p><strong>TL:DR:</strong> 略 <img src="http://ozlrjyp17.bkt.clouddn.com/62e721e4gw1et02g5wksrj200k00k3y9.jpg" alt=""></p><p><strong>PS:</strong> 代码格式如 4 格还是 2 格缩进，有无分号等都是程序员们争论不休的话题。个人觉得最好的方案就是遵守团队共同制定的标准，使用 <code>Eslint</code> 及其插件配合 CI 来做自动化检查。比较建议基于 <a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">airbnb</a> 做一些定制（比如去掉其中的分号限制 😀）。</p><h1 id="4-测试和总体质量"><a href="#4-测试和总体质量" class="headerlink" title="4 测试和总体质量"></a><code>4 测试和总体质量</code></h1><h2 id="4-1-至少要编写-API-（组件）测试"><a href="#4-1-至少要编写-API-（组件）测试" class="headerlink" title="4.1 至少要编写 API （组件）测试"></a>4.1 至少要编写 API （组件）测试</h2><p><strong>TL;DR:</strong> 由于排期很短，大多数项目都没有进行自动化测试，或者测试工程经常失控并被废弃。 因此，可以优先选择 API 测试，这是最容易编写的，并能提供比单元测试更多的覆盖率（你甚至可以使用 <a href="https://www.getpostman.com/" target="_blank" rel="noopener">Postman</a> 这样的工具来进行 API 测试而无需编写代码）。之后，如果你有更多的资源和时间，再继续进行单元测试，数据库测试，性能测试之类的高级测试。</p><p><strong>Otherwise:</strong> 你可能花了很多天去编写单元测试，结果只得到了 20% 的系统覆盖率。</p><h2 id="4-2-使用-ESLint-特定的-Node-规则插件来检测代码问题"><a href="#4-2-使用-ESLint-特定的-Node-规则插件来检测代码问题" class="headerlink" title="4.2 使用 ESLint + 特定的 Node 规则插件来检测代码问题"></a>4.2 使用 ESLint + 特定的 Node 规则插件来检测代码问题</h2><p><strong>TL;DR:</strong> <code>ESLint</code> 是用来检查代码风格的事实上的标准，不仅可用于识别基本的间距问题，还能用于检测严重的代码反模式，例如开发者抛出错误而没有进行分类。除了包含 <a href="https://en.wikipedia.org/wiki/JavaScript#Vanilla_JavaScript" target="_blank" rel="noopener">Vanilla JavaScript</a> 的 <code>ESLint</code> 标准规则之外，还添加了特定于 Node 的插件，如 <code>eslint-plugin-node</code>，<code>eslint-plugin-mocha</code> 和<code>eslint-plugin-node-security</code>。</p><p><strong>Otherwise:</strong> 很多不规范的 Node.JS 代码模式可能在眼皮子底下被漏过。例如，开发者可能用 <code>require(variableAsPath)</code> 去加载相关文件，其中的路径变量能让攻击者执行任何 JS 脚本。Node.JS lingter 可以检测到这种模式并提前告知。</p><h2 id="4-3-谨慎地选择你的CI平台-（Jenkins-vs-CircleCI-vs-Travis-vs-其他）"><a href="#4-3-谨慎地选择你的CI平台-（Jenkins-vs-CircleCI-vs-Travis-vs-其他）" class="headerlink" title="4.3 谨慎地选择你的CI平台 （Jenkins vs CircleCI vs Travis vs 其他）"></a>4.3 谨慎地选择你的CI平台 （Jenkins vs CircleCI vs Travis vs 其他）</h2><p><strong>TL;DR:</strong> 你的持续集成平台（CICD）将托管所有质量工具​​（例如测试，lint），因此它应该拥有充满活力的插件生态系统。<a href="https://jenkins.io/" target="_blank" rel="noopener">Jenkins</a> 曾经是许多项目的默认选择，因为它拥有最大的社区和一个非常强大的平台，但是它的代价则是复杂的设置以及需要一个陡峭的学习曲线。现在，使用  <a href="https://circleci.com" target="_blank" rel="noopener">CircleCI</a> 等 <code>SaaS</code> 工具使 CI 的解决方案变得更加容易。这些工具允许构建灵活的 CI 管道，而不需要管理整个基础设施。最终，这是鲁棒性和速度之间的权衡 —— 请谨慎地做出你的选择。</p><p><strong>Otherwise:</strong> 一旦需要一些高级的定制，选择一些 CI 平台可能会成为你的阻碍。而另一方面，使用 <code>Jenkin</code> 则可能会让你宝贵的时间消耗在基础设施上。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/testingandquality/citools.md" target="_blank" rel="noopener"><strong>Read More: Choosing CI platform</strong></a></p><h2 id="4-4-不断地检查易受攻击的依赖项"><a href="#4-4-不断地检查易受攻击的依赖项" class="headerlink" title="4.4 不断地检查易受攻击的依赖项"></a>4.4 不断地检查易受攻击的依赖项</h2><p><strong>TL;DR:</strong> 即便是最出名的模块包，例如 Express，也存在漏洞。依赖安全检查可以通过使用社区或商业化工具（例如可以在每个 CI 构建中调用 <a href="https://github.com/nodesecurity/nsp" target="_blank" rel="noopener">nsp</a> ）来轻松实现。</p><p><strong>Otherwise:</strong> 不用专用工具来进行代码漏洞保护，那么你需要不断地关注有关新漏洞的消息。这是非常无聊的。</p><h2 id="4-5-标记你的测试"><a href="#4-5-标记你的测试" class="headerlink" title="4.5 标记你的测试"></a>4.5 标记你的测试</h2><p><strong>TL;DR:</strong> 不同的测试必须在不同的场景下运行：</p><ul><li>冒烟测试应该在开发人员保存或提交文件时运行</li><li>完整的端到端测试通常在提交新的 <code>pull request</code> 时进行</li><li>其他等等</li></ul><p>这可以通过使用像 <code>#cold</code> <code>#api</code> <code>#sanity</code> 之类的关键词标记测试来实现，这样你就可以用你的测试工具 <code>grep</code> 所要调用子集。例如，你可以使用 <a href="https://mochajs.org/" target="_blank" rel="noopener">Mocha</a> 的<code>mocha --grep &#39;sanity&#39;</code> 来调用 <code>sanity</code> 测试组</p><p><strong>Otherwise:</strong> 运行所有的测试，包括执行数十个数据库查询的测试，使得任何时候开发者做一个小改动都会十分缓慢，并且这会让开发者远离测试。</p><h2 id="4-6-检查你的测试覆盖率，这有助于识别错误的测试模式"><a href="#4-6-检查你的测试覆盖率，这有助于识别错误的测试模式" class="headerlink" title="4.6 检查你的测试覆盖率，这有助于识别错误的测试模式"></a>4.6 检查你的测试覆盖率，这有助于识别错误的测试模式</h2><p><strong>TL;DR:</strong> 代码覆盖率工具如 <a href="https://github.com/gotwarlost/istanbul" target="_blank" rel="noopener">Istanbul/NYC </a>  是非常不错的项目，有三个原因：</p><ul><li>它是免费的（不用费劲来获得这个报告）</li><li>它有助于确定测试覆盖率的下降</li><li>它强调了测试未覆盖的地方：通过查看彩色的代码覆盖率报告，你可能注意到的，像 <code>catch</code> 子句那样的代码区域并没有被测试到（意味着测试只调用正确的路径，而不管应用程序的错误行为）</li></ul><p>如果覆盖率低于某个阈值，则将测试结果设置为失败。</p><p><strong>Otherwise:</strong> 当你的大部分代码未被测试覆盖时，将不会有任何自动化工具告诉你。</p><h2 id="4-7-检查过时的依赖包"><a href="#4-7-检查过时的依赖包" class="headerlink" title="4.7 检查过时的依赖包"></a>4.7 检查过时的依赖包</h2><p><strong>TL;DR:</strong> 使用你喜欢的工具（例如 <code>npm outdated</code> 或 <a href="https://www.npmjs.com/package/npm-check-updates" target="_blank" rel="noopener">npm-check-updates</a>）来检测已安装的依赖包是否过期，将此检查放到 CI  中进行，在严重的情况下甚至可以让构建失败。例如，一个可能的情况是当一个已安装的依赖包提交了 5 个补丁（例如本地版本是 1.3.1 而远程版本是 1.3.8），或者它的作者把它被标记为弃用时 —— 终止构建并阻止部署该版本。</p><p><strong>Otherwise:</strong> 你的产品将会运行被作者明确标记危险的依赖包。</p><h2 id="4-8-使用-docker-compose-进行-e2e-测试"><a href="#4-8-使用-docker-compose-进行-e2e-测试" class="headerlink" title="4.8 使用 docker-compose 进行 e2e 测试"></a>4.8 使用 docker-compose 进行 e2e 测试</h2><p><strong>TL;DR:</strong> 包含实时数据的端到端（e2e）测试，曾经是 CI 过程中最薄弱的环节，因为它依赖于多个像数据库一样繁重的服务。<code>docker-compose</code> 通过使用简单的文本文件和命令来制作类似的生产环境将这个问题变得简单。它允许制定所有的依赖服务，如数据库和网络隔离来进行 e2e 测试。最后但并非最不重要的一点是，它可以在每个测试套件调用之前的保持无状态环境，并且在使用之后立刻销毁。</p><p><strong>Otherwise:</strong> 没有 docker-compose 团队必须为每个测试环境（包括开发者的机器）维护一个测试数据库，并保持所有数据库同步以使测试结果不会因环境而异。</p><h1 id="5-投入生产使用"><a href="#5-投入生产使用" class="headerlink" title="5 投入生产使用"></a><code>5 投入生产使用</code></h1><h2 id="5-1-监控"><a href="#5-1-监控" class="headerlink" title="5.1 监控!"></a>5.1 监控!</h2><p><strong>TL;DR:</strong> 监控是一个抢在用户之前发现问题的游戏 —— 显然这应该被赋予前所未有的重要性。市场人员会因为报价而不知所措，因此可以考虑从定义你必须要的基本指标开始（如CPU, 内存, Node 进程的内存 (少于 1.4GB), 最近一分钟的错误数, 进程重启次数, 平均响应时间），然后再去看看更多的花式功能（如 DB 性能分析，跨服务测量，前端集成，将原始数据展示给自定义 BI 客户端, slack 提醒等），选择能够满足你条件的解决方案。</p><p><strong>Otherwise:</strong> 失败 === 失望的用户。 图森破🤓。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/production/monitoring.md" target="_blank" rel="noopener"><strong>Read More: Monitoring!</strong></a></p><h2 id="5-2-使用聪明的日志来提高透明度"><a href="#5-2-使用聪明的日志来提高透明度" class="headerlink" title="5.2 使用聪明的日志来提高透明度"></a>5.2 使用聪明的日志来提高透明度</h2><p><strong>TL;DR:</strong> 日志可能是一个充满调试语句的愚蠢仓库，或者是一个讲述应用程序故事的拥有漂亮面板的启动器。从第 1 天开始计划你的日志平台：如何收集，存储和分析日志以确保所需信息（例如，错误率，服务和服务之间的整个事务的追踪等）能够被真正提取。</p><p><strong>Otherwise:</strong> 你最终会碰到一个很难理解的黑盒，然后你开始重写所有的日志语句来添加额外的信息。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/production/smartlogging.md" target="_blank" rel="noopener"><strong>Read More: Increase transparency using smart logging</strong></a></p><h2 id="5-3-将任何可能的东西（例如gzip，SSL）放在反向代理中"><a href="#5-3-将任何可能的东西（例如gzip，SSL）放在反向代理中" class="headerlink" title="5.3 将任何可能的东西（例如gzip，SSL）放在反向代理中"></a>5.3 将任何可能的东西（例如gzip，SSL）放在反向代理中</h2><p><strong>TL;DR:</strong> Node 在执行 CPU 密集型任务（如gzipping，SSL终止等）时性能非常糟糕，所以可以使用 “真正的” 中间件服务，如 nginx，HAproxy 或 云平台服务作为代替。</p><p><strong>Otherwise:</strong> 你可怜的单线程将继续忙于做网络任务，而不是处理你应用程序的核心需求，因此性能会相应地降低。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/production/delegatetoproxy.md" target="_blank" rel="noopener"><strong>Read More: Delegate anything possible (e.g. gzip, SSL) to a reverse proxy</strong></a></p><h2 id="5-4-锁定依赖版本"><a href="#5-4-锁定依赖版本" class="headerlink" title="5.4 锁定依赖版本"></a>5.4 锁定依赖版本</h2><p><strong>TL;DR:</strong> 你的代码在所有环境中必须相同，但令人惊讶的是，默认情况下，NPM 允许依赖项跨环境偏移 —— 当你在不同环境下安装依赖包时，它会尝试拉取修订号最新的版本。通过使用 NPM 配置文件 <code>.npmrc</code> 可以解决这个问题，它告诉每个环境保存每个模块的确切（而不是最新）版本。或者，为了更细粒度的控制，可以使用 NPM <code>shrinkwrap</code>。<br>更新：从 NPM5 开始，依赖项被默认锁定。新的打包工具 Yarn 也默认了锁定了版本。</p><p><strong>Otherwise:</strong> QA 将彻底测试代码并同意使用在生产中可能表现不同的版本。更糟的是，同一个生产集群中的不同服务器可能会运行不同的代码。</p><p><strong>PS:</strong> 锁定依赖版本也会带来一些问题：</p><ul><li>业务使用版本和实际版本相差巨大，升级成本高</li><li>有些依赖包的 Bug 修复或功能优化无法得到及时更新，比如一些底层依赖修复了 OOM 问题</li><li>其他等</li></ul><p>所以有相当一部分团队不选择锁定版本，依靠选择符合语义化版本的开源模块和自动化测试等来规避依赖自动升级导致的问题。<br>我个人觉得几乎难以做到在一个项目里所使用的模块都是完全按语义化版本发布的（例如：有些开源模块的贡献者提交了一个小 patch 但是却引入了自己也没发现的新问题）所以倾向于使用依赖锁定，并在一个小的周期里进行及时更新。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/production/lockdependencies.md" target="_blank" rel="noopener"><strong>Read More: Lock dependencies</strong></a></p><h2 id="5-5-使用正确的工具来进行进程守护"><a href="#5-5-使用正确的工具来进行进程守护" class="headerlink" title="5.5 使用正确的工具来进行进程守护"></a>5.5 使用正确的工具来进行进程守护</h2><p><strong>TL;DR:</strong> 进程必须继续运行并且能在失败之后重启。对于简单的情况，像 PM2 这样的工具可能就足够了，但在当今 <code>dockerized</code> 的世界中，集群管理工具也应该被考虑在内。</p><p><strong>Otherwise:</strong> 运行数十个没有明确策略的实例以及太多的工具一起（集群管理，docker，PM2）可能会让 devops 陷入混乱。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/production/guardprocess.md" target="_blank" rel="noopener"><strong>Read More: Guard process uptime using the right tool</strong></a></p><h2 id="5-6-利用所有的-CPU"><a href="#5-6-利用所有的-CPU" class="headerlink" title="5.6 利用所有的 CPU"></a>5.6 利用所有的 CPU</h2><p><strong>TL;DR:</strong> 在其基本形式里，Node 应用在单个 CPU 上运行，而其他 CPU 都很空闲。你应该复制 Node 进程并利用所有 CPU —— 对于中小型应用，你可以使用 <code>Node Cluster</code> 或者 <code>PM2</code>。对于更大的应用，考虑使用一些 Docker 集群（例如 <code>K8S</code>，<code>ECS</code>）工具或基于 Linux init 系统（例如 <code>systemd</code>）的部署脚本来复制进程。</p><p><strong>Otherwise:</strong> 你的应用程序只使用了全部资源的 25％，甚至更少。请注意，一个典型的服务器有 4 个或更多的 CPU 内核，正常的 Node.JS 的部署只能使用 1 个（就算是使用了 <code>AWS beanstalk</code> 之类的 PaaS 服务！）</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/production/utilizecpu.md" target="_blank" rel="noopener"><strong>Read More: Utilize all CPU cores</strong></a></p><h2 id="5-7-创建一个-“维护端点”"><a href="#5-7-创建一个-“维护端点”" class="headerlink" title="5.7 创建一个 “维护端点”"></a>5.7 创建一个 “维护端点”</h2><p><strong>TL;DR:</strong> 在安全的环境中暴露一组与系统相关的 API，如内存使用和 REPL 等。尽管强烈建议使用久经考验的标准工具，但通过代码可以轻松获得一些有价值的信息以及执行一些相关操作。</p><p><strong>Otherwise:</strong> 你会发现你正在执行许多 “诊断部署” —— 为了提取一些信息用作诊断而将代码发布到生成环境。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/production/createmaintenanceendpoint.md" target="_blank" rel="noopener"><strong>Read More: Create a ‘maintenance endpoint’</strong></a></p><h2 id="5-8-使用-APM-产品来发现错误和停机时间"><a href="#5-8-使用-APM-产品来发现错误和停机时间" class="headerlink" title="5.8 使用 APM 产品来发现错误和停机时间"></a>5.8 使用 APM 产品来发现错误和停机时间</h2><p><strong>TL;DR:</strong> 监控和性能产品（又称 APM）主动测量你的代码和 API，所以他们可以超越传统的监控，并能跨越服务和层级来衡量整体用户体验。例如，某些 APM 产品可能会突出展示在用户终端加载速度过慢的事务，同时提示根本原因。</p><p><strong>Otherwise:</strong> 你可能会花很多精力去测量 API 的性能和停机时间，而且很可能你永远也不会察觉到哪些部分才是在真实情况下最慢的，以及它是如何影响用户体验的。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/production/apmproducts.md" target="_blank" rel="noopener"><strong>Read More: Discover errors and downtime using APM products</strong></a></p><h2 id="5-9-使你的代码-“生产就绪”"><a href="#5-9-使你的代码-“生产就绪”" class="headerlink" title="5.9 使你的代码 “生产就绪”"></a>5.9 使你的代码 “生产就绪”</h2><p><strong>TL;DR:</strong> 以结果为导向写码，从第 1 天开始计划上线。这听起来有些模糊，所以我汇总了一些与生产维护密切相关的开发技巧：</p><ul><li><a href="https://12factor.net/" target="_blank" rel="noopener">Twelve factors</a><ul><li>一份基准代码，多份部署</li><li>显式声明依赖关系</li><li>在环境变量中存储配置</li><li>把后端服务当作附加资源</li><li>严格分离构建和运行</li><li>以一个或多个无状态进程运行应用</li><li>通过端口绑定提供服务</li><li>通过进程模型进行扩展</li><li>快速启动和优雅终止可最大化鲁棒性</li><li>尽可能的保持开发、预发布、线上环境相同</li><li>把日志当作事件流</li><li>后台管理任务当作一次性进程运行</li></ul></li><li>保持无状态 —— 不在特定的服务器上保存状态数据</li><li>缓存 —— 大量使用缓存，但不会因缓存不匹配而失败</li><li>测试内存 —— 衡量内存使用和泄漏情况也是开发流程的一部分，类似 <code>memwatch</code> 之类的工具可以极大地简化这项任务</li><li>命名函数 —— 最小化匿名函数的使用（即内联回调），因为典型的内存分析器会提供每个命名方法的内存使用量。</li><li>使用 CI 工具 —— 使用 CI 工具在发布到生产环境之前进行故障检测。例如，使用 ESLint 来检测引用错误和未定义的变量。使用 <code>-trace-sync-io</code> 来标识使用同步 API 的代码</li><li>错误管理 —— 错误处理是整个 Node.JS 网站的薄弱环节。很多 Node 进程因为小错误而崩溃，而其他 Node 进程则处于故障状态。</li></ul><p><strong>Otherwise:</strong> 一个 IT/devops 世界冠军也拯救不了一个写得很烂的系统。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/production/productoncode.md" target="_blank" rel="noopener"><strong>Read More: Make your code production-ready</strong></a></p><h2 id="5-10-监测内存使用"><a href="#5-10-监测内存使用" class="headerlink" title="5.10 监测内存使用"></a>5.10 监测内存使用</h2><p><strong>TL;DR:</strong> Node.js 和内存之间的争议：v8 引擎对内存使用（1.4GB）具有软限制，并且在 Node 的代码中存在已知的途径来使内存泄漏，因此监测 Node 进程的内存是必须的。在小型应用中，你可以使用 shell 命令定期测量内存，但在大中型应用中，请考虑将内存监测放入到强大的监控系统中。</p><p><strong>Otherwise:</strong> 你的进程内存可能会和 Wallmart 里发生的情况一样，每天泄漏 100m。</p><p><strong>PS:</strong> 这个可以结合监控和报警来做，如果发生内存泄漏，一些 APM 也能帮助进行分析定位。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/production/measurememory.md" target="_blank" rel="noopener"><strong>Read More: Measure and guard the memory usage</strong></a></p><h2 id="5-11-让前端资源和-Node-解耦"><a href="#5-11-让前端资源和-Node-解耦" class="headerlink" title="5.11. 让前端资源和 Node 解耦"></a>5.11. 让前端资源和 Node 解耦</h2><p><strong>TL;DR:</strong> 使用专用中间件（nginx，S3，CDN）服务前端内容，因为 Node 是单线程模式，在处理多个静态文件时，其性能会受到影响。</p><p><strong>Otherwise:</strong> 你的单个 Node 线程将忙于传输数百个 html/images/angular/react 文件流，而不是将所有资源分给它真正的目的 —— 提供动态内容</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/production/frontendout.md" target="_blank" rel="noopener"><strong>Read More: Get your frontend assets out of Node</strong></a></p><h2 id="5-12-无状态，每天都杀掉你的服务"><a href="#5-12-无状态，每天都杀掉你的服务" class="headerlink" title="5.12 无状态，每天都杀掉你的服务"></a>5.12 无状态，每天都杀掉你的服务</h2><p><strong>TL;DR:</strong> 将无任什么类型的数据（例如，用户会话，缓存，上传的文件）放到外部存储中。考虑定期 “杀死” 你的服务，或者使用明确强制执行无状态行为的“无服务器”平台（例如AWS Lambda）。</p><p><strong>Otherwise:</strong> 特定的服务器出现故障将导致整个应用程序停机，而不是仅仅杀掉有故障的的机器。而且，由于对特定服务器的依赖，弹性扩展将变得更加艰难。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/production/bestateless.md" target="_blank" rel="noopener"><strong>Read More: Be stateless, kill your Servers almost every day</strong></a></p><h2 id="5-13-使用漏洞自动检测工具"><a href="#5-13-使用漏洞自动检测工具" class="headerlink" title="5.13 使用漏洞自动检测工具"></a>5.13 使用漏洞自动检测工具</h2><p><strong>TL;DR:</strong> 即便是最出名的模块包，例如 <code>Express</code>，也存在漏洞。可以通过使用社区或商业工具，不断地检查漏洞并报告（本地或GitHub），有些漏洞甚至可以立即修补。</p><p><strong>Otherwise:</strong> 不用专用工具来进行代码漏洞保护，那么你需要不断地关注有关新漏洞的消息。这是非常无聊的。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/production/detectvulnerabilities.md" target="_blank" rel="noopener"><strong>Read More: Use tools that automatically detect vulnerabilities</strong></a></p><h2 id="5-14-为每个日志语句分配-“TransactionId”"><a href="#5-14-为每个日志语句分配-“TransactionId”" class="headerlink" title="5.14 为每个日志语句分配 “TransactionId”"></a>5.14 为每个日志语句分配 “TransactionId”</h2><p><strong>TL;DR:</strong> 为单个请求中的每个日志条目分配相同的标识符 <code>transaction-id：{some value}</code>。<br>之后，在检查日志中的错误时，可以轻松地了解错误上下文。不幸的是，由于 Node 的异步性质，实现起来并不容易，请参考链接里的代码示例</p><p><strong>Otherwise:</strong> 在没有上下文的情况下查看生产环境里的错误日志会使得推断问题的原因变得更加困难和缓慢。</p><p><strong>PS:</strong> 可以在 API 网关里为每一个请求生成唯一的 <code>requst-id</code>，之后的每次内部调用都进行透传，并且在相关的每个日志中进行打印。再配合上 <code>ELK</code> 就能够非常方便的查询到一次请求和其相关的全部事务了。</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/production/assigntransactionid.md" target="_blank" rel="noopener"><strong>Read More: Assign ‘TransactionId’ to each log statement</strong></a></p><h2 id="5-15-设置-NODE-ENV-production"><a href="#5-15-设置-NODE-ENV-production" class="headerlink" title="5.15 设置 NODE_ENV=production"></a>5.15 设置 NODE_ENV=production</h2><p><strong>TL;DR:</strong> 将 <code>NODE_ENV</code> 设置为 <code>production</code> 或 <code>development</code> 来标记生产环境优化是否应该被启用 —— 许多 NPM 包会根据当前环境来决定是否优化代码。</p><p><strong>Otherwise:</strong> 省略这个简单的属性可能会大大降低性能。例如，当使用 Express 进行服务器端渲染时，忽略 NODE_ENV 会使速度降低三倍！</p><p>🔗 <a href="https://github.com/i0natan/nodebestpractices/blob/master/sections/production/setnodeenv.md" target="_blank" rel="noopener"><strong>Read More: Set NODE_ENV=production</strong></a></p><h2 id="5-16-设计自动的，原子的，零停机的部署"><a href="#5-16-设计自动的，原子的，零停机的部署" class="headerlink" title="5.16 设计自动的，原子的，零停机的部署"></a>5.16 设计自动的，原子的，零停机的部署</h2><p><strong>TL;DR:</strong> 研究表明，执行更多次部署的团队出现严重生产环境问题的概率更低。快速的自动化部署没有手动操作和服务当机的风险，大大改善了部署流程。你或许应该使用 Docker 和 CI 工具来实现这一点，因为它们已经成为简化部署的行业标准了。</p><p><strong>Otherwise:</strong> 长时间部署 -&gt; 生产环境停机时间 &amp; 人为错误 -&gt; 团队没有信心进行部署 -&gt; 功能和发布减少。</p><h1 id="6-安全"><a href="#6-安全" class="headerlink" title="6 安全"></a><code>6 安全</code></h1><h2 id="Our-contributors-are-working-on-this-section-Would-you-like-to-join"><a href="#Our-contributors-are-working-on-this-section-Would-you-like-to-join" class="headerlink" title="Our contributors are working on this section. Would you like to join?"></a>Our contributors are working on this section. Would you like to join?</h2><h1 id="7-性能"><a href="#7-性能" class="headerlink" title="7 性能"></a><code>7 性能</code></h1><h2 id="Our-contributors-are-working-on-this-section-Would-you-like-to-join-1"><a href="#Our-contributors-are-working-on-this-section-Would-you-like-to-join-1" class="headerlink" title="Our contributors are working on this section. Would you like to join?"></a>Our contributors are working on this section. Would you like to join?</h2><h1 id="Contributors"><a href="#Contributors" class="headerlink" title="Contributors"></a>Contributors</h1><h2 id="Yoni-Goldberg"><a href="#Yoni-Goldberg" class="headerlink" title="Yoni Goldberg"></a><code>Yoni Goldberg</code></h2><p>Independent Node.JS consultant who works with customers at USA, Europe and Israel on building large-scale scalable Node applications. Many of the best practices above were first published on his blog post at <a href="http://www.goldbergyoni.com" target="_blank" rel="noopener">http://www.goldbergyoni.com</a>. Reach Yoni at @goldbergyoni or <a href="mailto:me@goldbergyoni.com" target="_blank" rel="noopener">me@goldbergyoni.com</a></p><h2 id="Ido-Richter"><a href="#Ido-Richter" class="headerlink" title="Ido Richter"></a><code>Ido Richter</code></h2><p>👨‍💻 Software engineer, 🌐 web developer, 🤖 emojis enthusiast.</p><h2 id="Refael-Ackermann-refack-lt-refack-gmail-com-gt-he-him"><a href="#Refael-Ackermann-refack-lt-refack-gmail-com-gt-he-him" class="headerlink" title="Refael Ackermann @refack &lt;refack@gmail.com&gt; (he/him)"></a><code>Refael Ackermann</code> <a href="https://github.com/refack" target="_blank" rel="noopener">@refack</a> &lt;<a href="mailto:refack@gmail.com" target="_blank" rel="noopener">refack@gmail.com</a>&gt; (he/him)</h2><p>Node.js Core Collaborator, been noding since 0.4, and have noded in multiple production sites. Founded <code>node4good</code> home of <a href="https://github.com/node4good/lodash-contrib" target="_blank" rel="noopener"><code>lodash-contrib</code></a>, <a href="https://github.com/node4good/formage" target="_blank" rel="noopener"><code>formage</code></a>, and <a href="https://github.com/node4good/asynctrace" target="_blank" rel="noopener"><code>asynctrace</code></a>.<br><code>refack</code> on freenode, Twitter, GitHub, GMail, and many other platforms. DMs are open, happy to help.</p><h2 id="Bruno-Scheufler"><a href="#Bruno-Scheufler" class="headerlink" title="Bruno Scheufler"></a><code>Bruno Scheufler</code></h2><p>💻 full-stack web developer and Node.js enthusiast.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/i0natan/nodebestpractices&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="写码" scheme="http://eggggger.xyz/categories/programming/"/>
    
    
      <category term="Node" scheme="http://eggggger.xyz/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>SQL反模式</title>
    <link href="http://eggggger.xyz/2017/05/08/sql-antipatterns1/"/>
    <id>http://eggggger.xyz/2017/05/08/sql-antipatterns1/</id>
    <published>2017-05-08T14:12:31.000Z</published>
    <updated>2018-03-17T12:16:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为<a href="https://book.douban.com/subject/6800774/" target="_blank" rel="noopener">《SQL反模式》</a> —— 逻辑型数据库设计反模式章节的归纳整理</p><a id="more"></a><h3 id="乱穿马路"><a href="#乱穿马路" class="headerlink" title="乱穿马路"></a>乱穿马路</h3><hr><h4 id="存储多值属性"><a href="#存储多值属性" class="headerlink" title="存储多值属性"></a>存储多值属性</h4><h4 id="反模式：格式化的逗号分隔列表"><a href="#反模式：格式化的逗号分隔列表" class="headerlink" title="反模式：格式化的逗号分隔列表"></a>反模式：格式化的逗号分隔列表</h4><p>单个字段内用逗号分隔多个属性</p><p>引起的问题：</p><ul><li>单个字段结构有长度限制</li><li>无法正常使用关联查询</li><li>无法使用索引</li><li>无法使用聚合函数</li><li>无法保证引用完整性</li></ul><p>合理使用反模式：</p><ul><li>出于性能优化考虑</li><li>只作为值使用，不需要对其进行修改，和建立连接关系</li></ul><h4 id="反模式：创建多个列"><a href="#反模式：创建多个列" class="headerlink" title="反模式：创建多个列"></a>反模式：创建多个列</h4><p>创建多个列来存储多值属性</p><p>引起的问题：</p><ul><li>查询时需要搜索所有相关的列</li><li>更新和删除一个值前需要先查询出所有列进行分析</li><li>需要处理不断增长的值集</li></ul><p>合理使用反模式：</p><ul><li>一个属性只有固定数量的值集，且值的实际业务逻辑作用是不同的</li></ul><h4 id="解决方案：创建一个交叉表"><a href="#解决方案：创建一个交叉表" class="headerlink" title="解决方案：创建一个交叉表"></a>解决方案：创建一个交叉表</h4><p>创建一个交叉表，将多个值记录在多个行里而不是列里</p><h3 id="树形结构的存储与查询"><a href="#树形结构的存储与查询" class="headerlink" title="树形结构的存储与查询"></a>树形结构的存储与查询</h3><hr><h4 id="反模式：总是依赖父节点"><a href="#反模式：总是依赖父节点" class="headerlink" title="反模式：总是依赖父节点"></a>反模式：总是依赖父节点</h4><p>添加 <code>parent_id</code> 字段，即使用邻接表</p><p>引起的问题：</p><ul><li>查询一个节点的所有后代时，要么贴加相应层级数的关联查询，要么查出所有的行，在应用中进行处理</li><li>删除一个节点及其子树时，需要执行多次查询找到节点的后代进行删除</li><li>删除一个非叶节点并移动后代时，需要先修改子节点的 <code>parent_id</code>，然后才能进行移动</li></ul><p>合理使用反模式：</p><ul><li>业务需要快速获取给定节点的新节点，易于插入新节点，并且只有嵌套不深的有限层级（如2~3层）</li><li>使用 <code>PostgreSQL</code>、<code>Oracle</code> 等支持递归查询的数据库</li></ul><h4 id="解决方案：路径枚举"><a href="#解决方案：路径枚举" class="headerlink" title="解决方案：路径枚举"></a>解决方案：路径枚举</h4><p>使用 <code>path</code> 来代替 <code>parent_id</code>，类似 UNIX 文件系统的路径，在 <code>path</code> 中枚举所有的父节点如 <code>/parent_id_1/parent_id_2/self_id</code></p><p>优点</p><ul><li>可以比较方便的使用 <code>like</code> 查出指定节点的所有祖先和子节点</li><li>可以很方便的通过路径获取节点所在的层级</li></ul><p>缺点</p><ul><li>单字段有最大长度限制，无法支持无限扩展</li><li>无法保证引用完整性，需要依赖业务逻辑来维护路径格式和引用的正确</li></ul><h4 id="解决方案：嵌套集"><a href="#解决方案：嵌套集" class="headerlink" title="解决方案：嵌套集"></a>解决方案：嵌套集</h4><p>使用两个数字来编码每个节点，例入 <code>left</code> 和 <code>right</code>，<br><code>left</code> 小于该节点所有后代节点的 <code>id</code>，<code>right</code> 则大于所有后代节点的 <code>id</code></p><p>优点</p><ul><li>可以通过查询哪些节点的 <code>id</code> 在 <code>left</code> 和 <code>right</code> 之间来获取一个节点的所有子节点</li><li>可以通过查询一个节点的 <code>id</code> 在哪些节点 <code>left</code> 和 <code>right</code> 之间来获取它的祖先节点</li><li>删除一个非叶节点时，其子节点会代替删除的节点，成为其直接父节点的直接后代</li></ul><p>缺点</p><ul><li>需要复杂的查询才能找到一个节点的直接父节点或直接子节点</li><li>插入和移动一个节点时，需要相应的检查并更新其祖先和子孙节点 <code>left</code> 和 <code>right</code>，不适用需要频繁插入和移动节点的情况</li></ul><h4 id="解决方案：闭包表"><a href="#解决方案：闭包表" class="headerlink" title="解决方案：闭包表"></a>解决方案：闭包表</h4><p>创建一个额外的表来记录树中所有节点的关系，表包含 <code>ancestor</code> 和 <code>descendant</code> 字段来记录祖先和子代关系，同时也可以加入一个 <code>path_length</code> 来表示祖先到子代的距离，如 <code>path_length</code> 等于 0 表示自我引用，等于 1 表示直接子节点，以此类推。</p><p>优点：</p><ul><li>可以通过 <code>ancestor</code> 和 <code>descendant</code> 快速高效的查询一个节点所有的祖先节点和子节点</li><li>结合 <code>path_length</code> 可以快速查出直接父节点和直接子节点</li></ul><p>缺点：</p><ul><li>空间换时间，闭包表的条目数为实际数据的平方级</li></ul><h3 id="选择合适的主键"><a href="#选择合适的主键" class="headerlink" title="选择合适的主键"></a>选择合适的主键</h3><hr><h4 id="反模式：使用通用-ID-主键"><a href="#反模式：使用通用-ID-主键" class="headerlink" title="反模式：使用通用 ID 主键"></a>反模式：使用通用 ID 主键</h4><p>每个表都有一个通用主键，且具有三个特性：</p><ul><li>主键名叫做 <code>id</code></li><li>数据类型是 32 位和 64 位</li><li>主键的值是自动生成的以确保唯一性</li></ul><p>引起的问题：</p><ul><li>需要数据插入完成后才有主键</li><li>冗余键值，往往同时存在另一个逻辑上更自然的主键</li><li>因为主键业务无关，所以需要额外声明一个 UNIQUE 约束</li><li><code>id</code> 是一个意义不明的关键字，无法表达额外信息</li><li>无法使用 <code>USING</code> 关键字</li></ul><p>合理使用反模式：</p><ul><li>业务需求多变，使用业务无关的主键有时可以给自己留一条后路</li><li><code>InnoDB</code> 数据是按照主键聚簇的，使用自增主键可以避免磁盘的随机 IO 提高写入性能</li><li>二级索引存储了主键，使用联合索引或字符串作为主键会增大二级索引占用的空间，影响查询性能</li></ul><h4 id="解决方案：剪裁设计"><a href="#解决方案：剪裁设计" class="headerlink" title="解决方案：剪裁设计"></a>解决方案：剪裁设计</h4><ul><li>为主键选择更有意义的名称，如用 <code>user_id</code> 代替 <code>id</code></li><li>使用自然键和组合键作为主键</li></ul><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><hr><h4 id="反模式：无视外键约束"><a href="#反模式：无视外键约束" class="headerlink" title="反模式：无视外键约束"></a>反模式：无视外键约束</h4><p>为了使数据库设计更加高效灵活，设计表时不添加外键约束</p><p>引起的问题：</p><ul><li>无法完全保证数据的引用完整性（误操作，代码Bug等）</li><li>代码层面需要检查数据引用完整性，使得逻辑更加复杂（如更新，删除操作需要同时操作多表）</li></ul><p>合理使用反模式：</p><ul><li>应用对性能要求更高，对数据完整性要求较低</li><li>框架模型层已经能很好处理数据完整性问题</li><li>业务逻辑多变导致表结构经常需要变更</li></ul><h4 id="解决方案：声明外键约束"><a href="#解决方案：声明外键约束" class="headerlink" title="解决方案：声明外键约束"></a>解决方案：声明外键约束</h4><p>通过使用外键约束来保证数据完整性</p><h3 id="实体-属性-值-——-存储可变属性"><a href="#实体-属性-值-——-存储可变属性" class="headerlink" title="实体-属性-值 —— 存储可变属性"></a>实体-属性-值 —— 存储可变属性</h3><hr><h4 id="反模式：使用-EAV-模型"><a href="#反模式：使用-EAV-模型" class="headerlink" title="反模式：使用 EAV 模型"></a>反模式：使用 EAV 模型</h4><p>描述：将属性当做行来存储，使用 EAV 即 Entity-Attribute-Value 结构的表来支持可变属性，表中每条记录都包含实体（指向实体的外键）、属性、值三列</p><p>引起的问题：</p><ul><li>属性查询操作复杂化</li><li>无法声明 <code>NOT NULL</code></li><li>无法使用正确的数据结构，属性值一般只能是一个单纯的字符串</li></ul><p>合理使用反模式：</p><ul><li>绝大部分情况下不要考虑 EAV， 如果有大量非关系数据管理的需求，最好考虑使用非关系型数据库。</li></ul><h4 id="解决方案：-单表继承"><a href="#解决方案：-单表继承" class="headerlink" title="解决方案： 单表继承"></a>解决方案： 单表继承</h4><p>当数据的子类型和子类型的非公共属性很少时，可以使用单表存储所有子类型和属性，将所有相关的类型存放到一张表中，为每个类型的每个属性保留一列，使用一个 <code>type</code> 属性来标识类型</p><p>缺点：</p><ul><li>非公共属性存在很多空项，无法使用 <code>NOT NULL</code> 限制</li><li>缺乏元信息来标识一个属性属于哪个子类型</li></ul><h4 id="解决方案：实体表继承"><a href="#解决方案：实体表继承" class="headerlink" title="解决方案：实体表继承"></a>解决方案：实体表继承</h4><p>当业务中很少需要一次性查询所有子类型时，可以使用将每个子类型分别存储到不同的实体表中，每个表包含该类型的所有属性</p><p>缺点：</p><ul><li>添加通用属性时，需要对每个子类型表进行操作</li></ul><h4 id="类表继承"><a href="#类表继承" class="headerlink" title="类表继承"></a>类表继承</h4><p>使用一个基类表存储所有子类型的公共属性（同样需要一个 <code>type</code> 属性来区分子类型），对于每个子类型创建一个独立的表存储其特有属性，使用外键和基类表进行关联</p><p>缺点：</p><ul><li>需要额外的 <code>join</code> 来获取相应的子类型属性</li></ul><h4 id="半结构化数据模型"><a href="#半结构化数据模型" class="headerlink" title="半结构化数据模型"></a>半结构化数据模型</h4><p>当子类型数量很多或者需要经常变动属性时，可以使用一列来存储 <code>XML</code> 或者 <code>JSON</code> 格式</p><p>缺点：</p><ul><li>当你使用的数据库不支持类似 <code>JSON</code> 这样的特殊格式存储时，你无法对其中的一个属性进行限制，聚合运算，排序，添加索引等操作，并且你需要获取整个结构并在代码中去解码相应的属性</li></ul><h3 id="多态关联-——-单列属性引用多表"><a href="#多态关联-——-单列属性引用多表" class="headerlink" title="多态关联 —— 单列属性引用多表"></a>多态关联 —— 单列属性引用多表</h3><h4 id="反模式：使用额外的列来标识所引用的表"><a href="#反模式：使用额外的列来标识所引用的表" class="headerlink" title="反模式：使用额外的列来标识所引用的表"></a>反模式：使用额外的列来标识所引用的表</h4><p>添加一个额外的列来标识当前行所引用的表</p><p>引起的问题：</p><ul><li>无法声明外键约束</li><li>无法进行关联查询，需要在代码中进行判断后再增加一次查询</li></ul><p>合理使用反模式：</p><ul><li>不声明外键约束的情况下</li><li>无法使用 <code>join</code> 的情况下（如使用了数据库代理，分库分表等）</li></ul><h4 id="解决方案：反向引用"><a href="#解决方案：反向引用" class="headerlink" title="解决方案：反向引用"></a>解决方案：反向引用</h4><p>为每个被引用表创建一个交叉表</p><p>缺点：</p><ul><li>无法保证一个引用在多张交叉表中出现</li><li>额外的性能开销</li></ul><h4 id="解决方案：创建共用的超级表"><a href="#解决方案：创建共用的超级表" class="headerlink" title="解决方案：创建共用的超级表"></a>解决方案：创建共用的超级表</h4><p>使被引用的表继承一个共同的基类表，用基类表代替子类表建立关联关系</p><p>缺点：</p><ul><li>额外的性能开销</li></ul><h4 id="元数据分裂-——-数据表的扩展"><a href="#元数据分裂-——-数据表的扩展" class="headerlink" title="元数据分裂 —— 数据表的扩展"></a>元数据分裂 —— 数据表的扩展</h4><h4 id="反模式：克隆表"><a href="#反模式：克隆表" class="headerlink" title="反模式：克隆表"></a>反模式：克隆表</h4><p>将一个表拆分成多个结构相同的小表，使用表中一个特定数据字段来给拆分出来的表进行命名</p><p>引起的问题：</p><ul><li>不断产生新表</li><li>更新数据时，可能需要在不同克隆表中同步数据</li><li>跨表查询</li><li>变更表结构</li></ul><p>合理使用反模式：</p><ul><li>归档数据</li></ul><h4 id="解决方案：垂直拆分"><a href="#解决方案：垂直拆分" class="headerlink" title="解决方案：垂直拆分"></a>解决方案：垂直拆分</h4><p>根据业务情况将不常用的字段，大字段（如 <code>text</code>，<code>blob</code>）拆分到单独的表中</p><p>缺点：</p><ul><li>不是所有业务表都能拆分</li><li>不能完全解决数据量不断增长的问题</li></ul><h4 id="解决方案：水平拆分"><a href="#解决方案：水平拆分" class="headerlink" title="解决方案：水平拆分"></a>解决方案：水平拆分</h4><p>垂直拆分无法满足性能需求时，考虑进行水平拆分</p><p>缺点：</p><ul><li>切分规则相对复杂</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为&lt;a href=&quot;https://book.douban.com/subject/6800774/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《SQL反模式》&lt;/a&gt; —— 逻辑型数据库设计反模式章节的归纳整理&lt;/p&gt;
    
    </summary>
    
      <category term="写码" scheme="http://eggggger.xyz/categories/programming/"/>
    
    
      <category term="SQL" scheme="http://eggggger.xyz/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>【译】RESTful APIs, 一个巨大的谎言</title>
    <link href="http://eggggger.xyz/2017/01/04/restful-api/"/>
    <id>http://eggggger.xyz/2017/01/04/restful-api/</id>
    <published>2017-01-04T14:59:44.000Z</published>
    <updated>2018-03-12T16:13:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>为什么你会受益于让这个流行的范式归于平静？</p><a id="more"></a><p><img src="https://mmikowski.github.io/images/2015-08-10-rip-small.jpg" alt="RESTful API, rest in peace"></p><h3 id="重要更新"><a href="#重要更新" class="headerlink" title="重要更新"></a>重要更新</h3><p>我新增了关于  <a href="https://mmikowski.github.io/json-pure" target="_blank" rel="noopener">JSON-Pure APIs</a>  最佳实践的后续内容。但是在此之前，请先阅读下面的内容。</p><h3 id="RESTful-APIs-很好用，真的吗？"><a href="#RESTful-APIs-很好用，真的吗？" class="headerlink" title="RESTful APIs 很好用，真的吗？"></a>RESTful APIs 很好用，真的吗？</h3><p>如果你看过最近 10 年的互联网开发者简历或相关招聘信息，那么可以原谅你认为 <strong>RESTful APIs</strong> 是 Web 开发真神赐予的礼物。RESTful APIs 到处都是，甚至市场营销人员也把他们放在销售材料中推销给 CEO 和 HR.</p><p>所以 RESTful APIs  真的是一个好想法吗？在回答这个问题之前，让我们先看下 REST 的出处，以及 RESTful APIs 的定义。</p><h3 id="REST-的起源？"><a href="#REST-的起源？" class="headerlink" title="REST 的起源？"></a>REST 的起源？</h3><p>REST 流行起来是因为  <a href="https://en.wikipedia.org/wiki/Roy_Fielding" target="_blank" rel="noopener">Roy Fielding</a> 在他 2000 年的博士论文  <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank" rel="noopener">Architectural Styles and the Design of Network-based Software Architectures</a> 中介绍并推荐了它。Roy 因为他对 web 开发，特别是 HTTP 规范的贡献而闻名。</p><h3 id="什么是-RESTful-APIs-？"><a href="#什么是-RESTful-APIs-？" class="headerlink" title="什么是 RESTful APIs ？"></a>什么是 RESTful APIs ？</h3><p><a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="noopener">REST</a>  即表述性状态转移，是一种用于构建可扩展 web 服务的架构风格。Roy 提倡使用他在 HTTP 标准 中参与制定的请求方法来赋予 HTTP 请求语义。</p><p>因此当使用 REST 时，下面的 HTTP 请求都有不同的语义：</p><ul><li><code>GET /object/list</code></li><li><code>POST /object/list</code></li><li><code>PUT /object/list</code></li></ul><p>这只是一部分 HTTP 请求方法。完整的列表如下：<code>CONNECT</code>, <code>DELETE</code>, <code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>, <code>PATCH</code>, <code>POST</code>, <code>PUT</code>, <code>TRACE</code>。可以原谅你从没有听说过其中的某些方法，因为它们中的一部分也一直都没得到客户端或服务端的支持。<br>Roy 同样主张使用 他参与制定的 HTTP 响应状态码来传达响应的语义。共有 38 种 HTTP 响应状态码，下面是一个完整的列表。为了节约空间，我缩短了一些响应头：</p><table><thead><tr><th>Method</th><th>Method</th></tr></thead><tbody><tr><td>200 OK</td><td>201 Created</td></tr><tr><td>202 Accepted</td><td>203 Not authorized</td></tr><tr><td>204 No content</td><td>205 Reset content</td></tr><tr><td>206 Partial content</td><td></td></tr><tr><td>300 Multiple choice</td><td>301 Moved permanently</td></tr><tr><td>302 Found</td><td>303 See other</td></tr><tr><td>304 Not modified</td><td>306 (unused)</td></tr><tr><td>307 Temporary redirect</td><td></td></tr><tr><td>400 Bad request</td><td>401 Unauthorized</td></tr><tr><td>402 Payment required</td><td>403 Forbidden</td></tr><tr><td>404 Not found</td><td>405 Method not allowed</td></tr><tr><td>406 Not acceptable</td><td>407 Proxy auth required</td></tr><tr><td>408 Timeout</td><td>409 Conflict</td></tr><tr><td>410 Gone</td><td>411 Length required</td></tr><tr><td>412 Preconditions failed</td><td>413 Request entity too large</td></tr><tr><td>414 Requested URI too long</td><td>415 Unsupported media</td></tr><tr><td>416 Bad request range</td><td>417 Expectation failed</td></tr><tr><td>500 Server error</td><td>501 Not implemented</td></tr><tr><td>502 Bad gateway</td><td>503 Service unavailable</td></tr><tr><td>504 Gateway timeout</td><td>505 Bad HTTP version</td></tr></tbody></table><p>因此，这种基于 HTTP 的 API 事务最少包含了以下内容：</p><ul><li>the HTTP request method verb, e.g <code>GET</code></li><li>请求方法动词, 如 <code>GET</code></li><li>请求地址, 如 <code>/object/list</code></li><li>请求实体, 如 表单字段</li><li>响应状态码 如 <code>200 OK</code></li><li>响应实体, 如 JSON 数据</li></ul><p>许多人在通过 HTTP 提供 web 服务时接受了这种模式，而这就是我们所说的 <strong>RESTful API</strong>.</p><p>由于各种原因，RESTful API 可能比上面显示的更复杂，其中一些我们会在下文中讨论。我们将忽略和网络传输及缓存有关的复杂因素，因为这些问题对所有通信渠道是通用的。</p><h3 id="RESTful-APIs-事实上是相当糟糕的"><a href="#RESTful-APIs-事实上是相当糟糕的" class="headerlink" title="RESTful APIs 事实上是相当糟糕的"></a>RESTful APIs 事实上是相当糟糕的</h3><p>在许多方面，例如内容交付上，REST 都是一个不错的机制，它也很好得为我们服务了二十多年。但是是时候打破沉默了，承认 RESTful API 可能是在 web 软件中广泛使用的最糟糕的想法之一。Roy 或许是一个厉害的家伙，他也的确有很多不错的想法。可是无论如何，我都不相信  RESTful APIs 是其中之一。</p><p>我们很快将看到更好的构建互联网 API 的方式，但在完全领会这个解决方案之前，我们首先得知道 RESTful APIs 的 5 个主要问题，它们使 API 昂贵，冗余，并且容易出错。让我们开始吧！</p><h3 id="问题-1-关于-RESTful-API-是什么，几乎达不成共识"><a href="#问题-1-关于-RESTful-API-是什么，几乎达不成共识" class="headerlink" title="问题 #1: 关于 RESTful API 是什么，几乎达不成共识"></a>问题 #1: 关于 RESTful API 是什么，几乎达不成共识</h3><p>你有没有注意到没有人称呼他们的 API 为 “RESTpure”？ 他们叫它 “RESTful” 或者 “RESTish”。那是因为没有人能够在全部的请求方法，实体和响应状态码的真正含义上达成一致。<br>设想一下，例如，我们应该用 <code>200 OK</code> 表示成功的更新了一条记录还是要用 <code>201 Created</code>？看上去我们应该用 <code>250 Updated</code>，但是这个状态码并不存在。而且谁能向我解释一下 <code>417 Expectation failed</code> 的真正含义。当然我是指除了 Roy 之外的人。</p><p>HTTP 方法和响应状态码的词汇过于模糊和不完整，无法就其语义达成一致。至少在我所知道的，没有任何管理机构能召集大家一起把事情讲清楚。一个公司定义的 <code>200 OK</code> 必然与另一家公司定义的有细微且令人讨厌的区别。这意味着一个 RESTful 模式不能像我们想要的那样可以预测。<br>如果只有这一个问题，我可能还会用 RESTful APIs。但 RESTful APIs 的问题层出不穷…</p><h3 id="问题-2-REST-词汇的支持不完全"><a href="#问题-2-REST-词汇的支持不完全" class="headerlink" title="问题 #2:  REST 词汇的支持不完全"></a>问题 #2:  REST 词汇的支持不完全</h3><p>即使就 REST 的各个语义达成一致，我们还会遇到另一个实际的问题：大部分客户端和服务器程序不能完全支持 HTTP 协议 里定义的动词或响应状态码。例如，大部分浏览器对<code>PUT</code> 或 <code>DELETE</code> 仅提供有限的支持。并且很多服务端程序通常也不能正确地实现这些方法。</p><p>那么我们如何突破这些限制呢？一种常用的方法是在浏览器的表单里嵌入预期的请求方法。这意味着 REST 请求现在包含：</p><ul><li>一个 HTTP 请求方法, 如 <code>POST</code></li><li>一个请求地址, 如 <code>/object/list</code></li><li>一个我们实际期望的方法，嵌入在请求的实体中，如  <code>DELETE</code></li><li>请求实体本身，如表单字段数据</li></ul><p>响应状态码的处理也好不到哪去。不同的 web 浏览器 (或者服务器) 对响应状态码的解释也经常各不一样。例如，如果遇到 <code>307 Temporary redirect</code> 状态码，一个浏览器可能允许客户端JavaScript 在重定向之前处理响应并取消它，另一个浏览器可能就禁止客户端 JavaScript 处理响应。所有程序中真正可靠的响应状态码只有 <code>200 OK</code> 和 <code>500 Internal server error</code>。除此之外，支持程度一个比一个糟糕。因此，我们也常常可以看到在返回的的实体里嵌入有实际想要的响应状态码。<br>当然，即使我们能让每个人都对什么是 REST 达成一致，并神奇地修复所有已连入互联网的程序对 REST 支持的缺陷，我们仍然还有一个问题：REST 词汇不够丰富。</p><h3 id="问题-3-REST-词汇对-APIs-来说不够丰富"><a href="#问题-3-REST-词汇对-APIs-来说不够丰富" class="headerlink" title="问题 #3: REST 词汇对 APIs 来说不够丰富"></a>问题 #3: REST 词汇对 APIs 来说不够丰富</h3><p>REST 的方法和响应状态码太过于局限，无法有效地表示所有应用程序所需的各种请求和响应。想一下，我们创建了一个应用程序，并要向 HTTP 客户端 发送一个 “render complete” 响应。我们不能使用 HTTP 响应状态码，因为它不存在并且 HTTP 不能扩展。好吧，我想我们还是把实际预期的状态码嵌入到响应实体中去吧。</p><p>还有另外一个问题：HTTP 响应状态码 (200, 201, 202 等) 是和 HTTP 请求方法 (<code>GET</code>, <code>POST</code> 等)没有直接联系的数字，而我们的实体载荷通常是 JSON 格式。所以执行 REST 请求就好像发送一个目的地是斯瓦希里却包含英语内容的包裹，并通过打鼓声来获得交付确认。这种复杂性往往会造成巨大的困惑和错误。它给我们带来了下一个问题：调试。</p><h3 id="问题-4-RESTful-APIs-非常难调试"><a href="#问题-4-RESTful-APIs-非常难调试" class="headerlink" title="问题 #4: RESTful APIs 非常难调试"></a>问题 #4: RESTful APIs 非常难调试</h3><p>如果你曾经用过 RESTful API，你大概知道他们几乎难以调试。这是因为我们必须查看 7 个不同的地方来整理出一个完整的事务中发生了什么：</p><ul><li>HTTP 请求方法, 如 <code>POST</code></li><li>请求地址, 如 <code>/object/list</code></li><li>请求实体中嵌入的实际期望的方法，如 <code>DELETE</code></li><li>请求实体中的实际数据，如 表单数据</li><li>响应状态码，如 <code>200 OK</code></li><li>响应实体中嵌入的实际期望的响应状态码，如 <code>206 Partial content</code></li><li>响应实体中的实际数据</li></ul><p>我们的问题不仅有两个 REST 词汇上的限制，大家就语义达不成一致。现在还有需要查找 7 个不同的地方才可能完全理解和调试一个事务。唯一还能使这更糟的事是，REST 完全绑定到了一个协议上，而不适用于任何其他的协议。当然，这也是我们的下一个问题。</p><h3 id="问题-5-RESTful-APIs-通常绑定在-HTTP-上"><a href="#问题-5-RESTful-APIs-通常绑定在-HTTP-上" class="headerlink" title="问题  #5: RESTful APIs 通常绑定在 HTTP 上"></a>问题  #5: RESTful APIs 通常绑定在 HTTP 上</h3><p>RESTful API 打破了良好通信的一个基本原则：消息内容应该独立于传输通道。将两者混合来迷惑读者是一个历史悠久的方法。</p><p>将 HTTP 协议 与事务的意义混合使得 RESTful API 完全不可移植。将 RESTful API 从 HTTP 迁移 到其他传输协议上需要从 7 个不同的地方解构和重组信息，我们再使用这些信息对 RESTful 请求的全部含义进行编码。</p><p>幸运的是有一个更好的解决方案，避免或减轻了几乎所有 RESTful APIs 的问题。我们将这个解决方案称为 <strong> JSON-Pure APIs </strong>。</p><h3 id="未来的方向：-JSON-Pure-APIs"><a href="#未来的方向：-JSON-Pure-APIs" class="headerlink" title="未来的方向： JSON-Pure APIs"></a>未来的方向： JSON-Pure APIs</h3><p><a href="https://mmikowski.github.io/the_lie/json-pure" target="_blank" rel="noopener">JSON-Pure APIs</a> 解决了我们刚刚讨论的大部分问题。</p><ul><li>它们只使用一种传输方法来发送请求 -  如 <code>POST</code> 用于 HTTP 或 <code>send</code>  用于 WebSockets。</li><li>它们将请求内容与传输机制完全分离。所有的错误，警告和数据通通放在 JSON 请求实体中。</li><li>它们只用一个响应状态码来确认消息的正确接收 - 如 HTTP 的 <code>200 OK</code>。</li><li>它们将响应内容与传输机制完全分离。所有的错误，警告和数据通通放在 JSON 请求实体中。</li><li>它们易于调试，因为事务信息可以在使用了单个特定领域词汇的实体中的易读 JSON 里找到。</li><li>它们可以轻松地在传输协议中迁移和共享，如 HTTP/S，WebSockets，XMPP，telnet，SFTP，SCP 或 SSH</li></ul><p>JSON-Pure APIs  的产生是因为开发者发现  RESTful APIs  对浏览器或开发人员不是很友好。在 API 中将信息和传输通道分离，通常会更快，并且总是更可靠，更易于使用，迁移和调试。现在，如果你使用 Twitter API，受虐狂可以选择 RESTful API，而我们其他人则可以使用 JSON-Pure API (他们叫它 “Web API”)。</p><p>在过去的十年里，我经常被要求使用 RESTful API 来代替 JSON-Pure。上一次我不得不支持一个 RESTful API 是在2011年。值得庆幸的是，服务端团队同意通过简单地将他们的 HTTP 方法 和 响应状态码 填充到 JSON 中来提供 JSON-Pure API 以及 RESTful 变体。几个月以后，我认识的每一个人使用 API 的人都切换到 JSON-Pure 版本了。这相比之前好多了。</p><h3 id="JSON-Pure-APIs-的未来"><a href="#JSON-Pure-APIs-的未来" class="headerlink" title="JSON-Pure APIs 的未来"></a>JSON-Pure APIs 的未来</h3><p><strong>更新</strong>: 我新增了一些内容来解释 <a href="https://mmikowski.github.io/json-pure" target="_blank" rel="noopener">JSON-Pure APIs</a> 的最佳实践的细节。当然，这些建议并不是在任何情况下都是最佳的，但它们的确被我频繁地用于需要响应 <a href="https://www.amazon.com/Single-Page-Applications-end---end/dp/1617290750" target="_blank" rel="noopener">单页 Web 应用</a> 的 API 类型上。一如既往，你的道路可能会有所不同。但是如果你的用例和我一样的话，你可能会想让你的下一代 API “RESTless” 并且 “go Pure”。</p><p>Cheers, Mike</p><p>Written on August 10, 2015</p><blockquote><p>本文转载自：<a href="http://www.zcfy.cc" target="_blank" rel="noopener">众成翻译</a><br>译者：<a href="http://www.zcfy.cc/@eggggger" target="_blank" rel="noopener">eggggger</a><br>链接：<a href="http://www.zcfy.cc/article/2155" target="_blank" rel="noopener">http://www.zcfy.cc/article/2155</a><br>原文：<a href="https://mmikowski.github.io/the_lie/" target="_blank" rel="noopener">https://mmikowski.github.io/the_lie/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么你会受益于让这个流行的范式归于平静？&lt;/p&gt;
    
    </summary>
    
      <category term="写码" scheme="http://eggggger.xyz/categories/programming/"/>
    
    
      <category term="OpenSearch" scheme="http://eggggger.xyz/tags/OpenSearch/"/>
    
  </entry>
  
  <entry>
    <title>【译】你应该要知道的 Linux 知识 - Julia Evans</title>
    <link href="http://eggggger.xyz/2016/12/12/things-to-learn-about-linux/"/>
    <id>http://eggggger.xyz/2016/12/12/things-to-learn-about-linux/</id>
    <published>2016-12-12T06:40:31.000Z</published>
    <updated>2018-03-12T16:10:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>我在 Twitter 上问了网友们更有兴趣了解 Linux 的什么东西。其中有很多回复非常不错，这里整理出了一个列表（其中有许多是可以在任何 Unixy 系统上讨论的，另一些则特定于 Linux）</p><a id="more"></a><ul><li><p>tcp/ip &amp; 网络相关</p></li><li><p>什么是 port/socket?</p></li><li><p>seccomp (Linux 内核提供的一种沙盒机制)</p></li><li><p>systemd (系统服务管理器，启动守护进程等)</p></li><li><p>IPC (进程间通信，管道)</p></li><li><p>r, w, x (文件权限)，SetUid, SetGid, Sticky Bit (文件特殊权限), chown 如何工作？</p></li><li><p>shell 如何使用 fork &amp; exec？</p></li><li><p>怎么让我的电脑变成路由器？</p></li><li><p>process groups (进程组), session leaders (会话领导进程), shell job control (工作管理)</p></li><li><p>内存分配, 堆的工作原理, malloc 做了什么？</p></li><li><p>ttys，终端是如何工作的？</p></li><li><p>process scheduling (进程调度)</p></li><li><p>drivers (驱动程序)</p></li><li><p>Linux 和 Unix 的区别？</p></li><li><p>kernel (内核)</p></li><li><p>现代 X (窗口系统协议) 服务器？</p></li><li><p>X11 (X 协议 11 版本) 如何工作？</p></li><li><p>Linux’s zero-copy (零拷贝) API (sendfile, splice, tee)</p></li><li><p>dmesg (显示内核缓存区信息) 还能做什么？</p></li><li><p>内核模块如何工作？</p></li><li><p>嵌入式相关: realtime (实时)namespaces (环境隔离)， cgroups (进程组群)，docker (容器)， SELinux (安全增强 Linux)，AppArmor (内核安全模块，应用程序访问控制)</p></li><li><p>debuggers (调试器)</p></li><li><p>线程和进程的区别？</p></li><li><p>如果 Unix 是基于命令行的，桌面环境如 GNOME 是怎么实现的？</p></li><li><p>man 是如何工作的？</p></li><li><p>kpatch (内核热补丁技术 by Red Hat), kgraph (内核热补丁技术 by SUSE), kexec (内核热切换)</p></li><li><p>栈相关的： C 的变量实际上是 stack slot (栈槽)？tf (trap flag ?) 怎么做 setjmp<br>和 longjmp 的工作?</p></li><li><p>package management (包管理器)</p></li><li><p>mounts and vfs (挂载和虚拟文件系统)</p></li></ul><p>有很多理由表明这些知识点都很不错：</p><ol><li><p>这个月我要画至少 11 张关于 Linux 的图，它们都是不错的点子。</p></li><li><p>这个列表里的有些东西我都不知道是什么 (dbus, SELinux) ，要不就只是听到过一点 (seccomp， X11 如何工作，以及其他更多)，它提醒我还有许多有趣的东西需要去学习。</p></li><li><p>它让我知道自己掌握到了什么程度 — 虽然在不查资料的情况下我不能解释清楚其中的很多东西，但我至少知道从哪里去了解它们。</p></li></ol><p>此外，我想提醒你们可以在网上写一些有趣的博客/图，例如 “dmesg 能做什么”就是一个不错的主题，你也很有可能因此去学习了解它 (我在维基百科上阅读了<a href="https://en.wikipedia.org/wiki/Dmesg" target="_blank" rel="noopener">dmesg</a>，现在，我比以前了解的更深入了)</p><blockquote><p>本文转载自：<a href="http://www.zcfy.cc" target="_blank" rel="noopener">众成翻译</a><br>译者：<a href="http://www.zcfy.cc/@eggggger" target="_blank" rel="noopener">eggggger</a><br>链接：<a href="http://www.zcfy.cc/article/1990" target="_blank" rel="noopener">http://www.zcfy.cc/article/1990</a><br>原文：<a href="https://jvns.ca/blog/2016/11/21/things-to-learn-about-linux/" target="_blank" rel="noopener">https://jvns.ca/blog/2016/11/21/things-to-learn-about-linux/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在 Twitter 上问了网友们更有兴趣了解 Linux 的什么东西。其中有很多回复非常不错，这里整理出了一个列表（其中有许多是可以在任何 Unixy 系统上讨论的，另一些则特定于 Linux）&lt;/p&gt;
    
    </summary>
    
      <category term="写码" scheme="http://eggggger.xyz/categories/programming/"/>
    
    
      <category term="Linux" scheme="http://eggggger.xyz/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【译】Node.js 垃圾回收</title>
    <link href="http://eggggger.xyz/2016/10/22/node-gc/"/>
    <id>http://eggggger.xyz/2016/10/22/node-gc/</id>
    <published>2016-10-22T14:34:53.000Z</published>
    <updated>2018-03-12T16:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章中，你可以学到 Node.js 的垃圾回收 (以下简称 GC ) 是怎么工作的，你写下的代码在后台发生了什么，以及内存是如何释放的。</p><a id="more"></a><center><br><img src="http://ogovd1xl2.bkt.clouddn.com/ancient-garbage-collector-in-action.jpg" alt="ancient-garbage-collector-in-action"><br></center><h3 id="Node-js-应用中的内存管理"><a href="#Node-js-应用中的内存管理" class="headerlink" title="Node.js 应用中的内存管理"></a>Node.js 应用中的内存管理</h3><p>每个应用都需要内存才能正常运行。内存管理能动态的分配内存块给需要的程序，在不需要时释放掉，以便能重复使用。</p><p>应用级的内存管理可以是手动或自动的。而自动内存管理往往涉及到 GC。</p><p>下面的代码片段展示了在 C 中如何使用手动内存管理分配内存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">   char name[20];</span><br><span class="line">   char *description;</span><br><span class="line"></span><br><span class="line">   strcpy(name, &quot;RisingStack&quot;);</span><br><span class="line"></span><br><span class="line">   // memory allocation</span><br><span class="line">   description = malloc( 30 * sizeof(char) );</span><br><span class="line"></span><br><span class="line">   if( description == NULL ) &#123;</span><br><span class="line">      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      strcpy( description, &quot;Trace by RisingStack is an APM.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   printf(&quot;Company name = %s\n&quot;, name );</span><br><span class="line">   printf(&quot;Description: %s\n&quot;, description );</span><br><span class="line"></span><br><span class="line">   // release memory</span><br><span class="line">   free(description);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>手动内存管理</strong>中，开发者有责任释放闲置的内存，这种内存管理方式可能会造成下面几个问题：</p><ul><li><strong>内存泄露</strong>，当从不释放使用过的内存时发生</li><li><strong>野指针</strong>，当对象被释放时，而原来的指针仍继续使用。在其他数据覆盖写入或读取敏感信息时会造成严重的安全问题</li></ul><p><strong>值得庆幸的是，Node.js 附带了一个垃圾回收器，你不需要去手动管理内存分配</strong></p><h3 id="GC-的理念"><a href="#GC-的理念" class="headerlink" title="GC 的理念"></a>GC 的理念</h3><p>GC 是一种自动管理应用内存的方法。GC 的工作是回收被未使用的对象所占用的内存。它在 1959 年首次应用于 John McCarthy 创造的 LISP 中。</p><p>GC 判断对象不再使用的方式是没有其他的对象引用它们。</p><h6 id="GC-前的内存"><a href="#GC-前的内存" class="headerlink" title="GC 前的内存"></a>GC 前的内存</h6><p>你的内存看上去如下图所示，如果你有一些互相引用的对象以及一些没有任何引用的对象。这些没有引用的对象会在 GC 运行 时被回收。</p><center><br><img src="http://ogovd1xl2.bkt.clouddn.com/memory-state-before-node-js-garbage-collection.png" alt="memory-state-before-node-js-garbage-collection"><br></center><h6 id="GC-后的内存"><a href="#GC-后的内存" class="headerlink" title="GC 后的内存"></a>GC 后的内存</h6><p>当 GC 运行起来，无法访问 (没有引用) 的对象会被删除，同时释放掉相应的内存空间。</p><center><br><img src="http://ogovd1xl2.bkt.clouddn.com/memory-state-after-node-js-garbage-collection.png" alt="memory-state-after-node-js-garbage-collection"><br></center><h4 id="GC-的优点"><a href="#GC-的优点" class="headerlink" title="GC 的优点"></a>GC 的优点</h4><ul><li>防止了野指针 bug</li><li>不用担心内存的二次释放</li><li>避免了一些类型的内存泄露</li></ul><p>当然，使用 GC 不能解决你所有的问题，而且它也不是内存管理的银弹。</p><h6 id="使用-GC-时需要注意的事项"><a href="#使用-GC-时需要注意的事项" class="headerlink" title="使用 GC 时需要注意的事项"></a>使用 GC 时需要注意的事项</h6><ul><li><strong>性能影响</strong> - GC 会消耗计算能力去决定什么对象应该释放</li><li><strong>无法预测的停顿</strong> - 现代 GC 实现尝试去避免 <strong>stop-the-world</strong> 的回收方式</li></ul><h3 id="Node-js-GC-amp-内存管理实践"><a href="#Node-js-GC-amp-内存管理实践" class="headerlink" title="Node.js GC &amp; 内存管理实践"></a>Node.js GC &amp; 内存管理实践</h3><p>实践出真知，所以我打算通过几段不同的代码向你展示内存中发生了什么</p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈上包含了局部变量和指向堆上对象或指向应用程序控制流程的指针。<br>在以下示例中，a和b将会被放置在栈中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add (a, b) &#123;  </span><br><span class="line">  return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(4, 5)</span><br></pre></td></tr></table></figure><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆专门用于存储引用类型对象，如字符串和对象。<br>在以下示例中，Car 对象将会被放置在堆中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Car (opts) &#123;  </span><br><span class="line">  this.name = opts.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const LightningMcQueen = new Car(&#123;name: &apos;Lightning McQueen&apos;&#125;)</span><br></pre></td></tr></table></figure><p>在这之后，内存看起来像这个样子</p><center><br><img src="http://ogovd1xl2.bkt.clouddn.com/node-js-garbage-collection-first-step-object-placed-in-memory-heap.png" alt="node-js-garbage-collection-first-step-object-placed-in-memory-heap"><br></center><p>让我们添加更多的 Car 对象，看看内存会是什么样子！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Car (opts) &#123;  </span><br><span class="line">  this.name = opts.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const LightningMcQueen = new Car(&#123;name: &apos;Lightning McQueen&apos;&#125;)  </span><br><span class="line">const SallyCarrera = new Car(&#123;name: &apos;Sally Carrera&apos;&#125;)  </span><br><span class="line">const Mater = new Car(&#123;name: &apos;Mater&apos;&#125;)</span><br></pre></td></tr></table></figure><center><br><img src="http://ogovd1xl2.bkt.clouddn.com/node-js-garbage-collection-second-step-more-elements-added-to-the-heap.png" alt="node-js-garbage-collection-second-step-more-elements-added-to-the-heap"><br></center><p>如果GC现在运行，由于根有对每个对象的引用，没有对象会被释放。</p><p>让我们添加一些零件到我们的汽车里 (Car 对象) 使它更有趣一点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Engine (power) &#123;  </span><br><span class="line">  this.power = power</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Car (opts) &#123;  </span><br><span class="line">  this.name = opts.name</span><br><span class="line">  this.engine = new Engine(opts.power)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let LightningMcQueen = new Car(&#123;name: &apos;Lightning McQueen&apos;, power: 900&#125;)  </span><br><span class="line">let SallyCarrera = new Car(&#123;name: &apos;Sally Carrera&apos;, power: 500&#125;)  </span><br><span class="line">let Mater = new Car(&#123;name: &apos;Mater&apos;, power: 100&#125;)</span><br></pre></td></tr></table></figure><center><br><img src="http://ogovd1xl2.bkt.clouddn.com/node-js-garbage-collection-assigning-values-to-the-objects-in-heap.png" alt="node-js-garbage-collection-assigning-values-to-the-objects-in-heap"><br></center><p>如果我们不再使用 Mater，但是重新定义并对它赋值 (如Mater = undefined) 会发生什么？</p><center><br><img src="http://ogovd1xl2.bkt.clouddn.com/node-js-garbage-collection-redefining-values.png" alt="node-js-garbage-collection-redefining-values"><br></center><p>结果就是，无法从根上访问 Master 对象。所以当下一次 GC 运行时，它将会被释放：</p><center><br><img src="http://ogovd1xl2.bkt.clouddn.com/node-js-garbage-collection-freeing-up-unreachable-object.png" alt="node-js-garbage-collection-freeing-up-unreachable-object"><br></center><p>现在我们了解了 GC 预期行为的基础，那让我们看看它在 V8 中是如何实现的。</p><h4 id="GC-方法"><a href="#GC-方法" class="headerlink" title="GC 方法"></a>GC 方法</h4><p>在我们之前的一篇文章中，我们讨论了 <a href="https://blog.risingstack.com/finding-a-memory-leak-in-node-js/" target="_blank" rel="noopener">Node.js GC 方法是如何工作的</a>，所以我强烈建议去阅读这篇文章。</p><ul><li>新生区和老生区</li><li>新生代 (Young Generation)</li><li>Scavenge 和 标记删除</li></ul><h3 id="一个真实的例子-—-The-Meteor-Case-Study"><a href="#一个真实的例子-—-The-Meteor-Case-Study" class="headerlink" title="一个真实的例子 — The Meteor Case-Study"></a>一个真实的例子 — The Meteor Case-Study</h3><p>在 2013 年，Meteor 的作者宣布了他们碰到的关于内存泄露的发现，问题代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var theThing = null  </span><br><span class="line">var replaceThing = function () &#123;  </span><br><span class="line">  var originalThing = theThing</span><br><span class="line">  var unused = function () &#123;</span><br><span class="line">    if (originalThing)</span><br><span class="line">      console.log(&quot;hi&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  theThing = &#123;</span><br><span class="line">    longStr: new Array(1000000).join(&apos;*&apos;),</span><br><span class="line">    someMethod: function () &#123;</span><br><span class="line">      console.log(someMessage)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">setInterval(replaceThing, 1000)</span><br></pre></td></tr></table></figure><blockquote><p>Well, the typical way that closures are implemented is that every function object has a link to a dictionary-style object representing its lexical scope. If both functions defined inside replaceThing actually used originalThing, it would be important that they both get the same object, even if originalThing gets assigned to over and over, so both functions share the same lexical environment. Now, Chrome’s V8 JavaScript engine is apparently smart enough to keep variables out of the lexical environment if they aren’t used by any closures - from the <a href="http://info.meteor.com/blog/an-interesting-kind-of-javascript-memory-leak" target="_blank" rel="noopener">Meteor blog</a>.</p></blockquote><h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><p><a href="https://blog.risingstack.com/node-js-at-scale-node-js-garbage-collection/?utm_source=nodeweekly&amp;utm_medium=email" target="_blank" rel="noopener">Node.js at Scale - Node.js Garbage Collection Explained</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这篇文章中，你可以学到 Node.js 的垃圾回收 (以下简称 GC ) 是怎么工作的，你写下的代码在后台发生了什么，以及内存是如何释放的。&lt;/p&gt;
    
    </summary>
    
      <category term="写码" scheme="http://eggggger.xyz/categories/programming/"/>
    
    
      <category term="Node" scheme="http://eggggger.xyz/tags/Node/"/>
    
      <category term="GC" scheme="http://eggggger.xyz/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Why HTTP/2 ?</title>
    <link href="http://eggggger.xyz/2016/10/17/why-http2/"/>
    <id>http://eggggger.xyz/2016/10/17/why-http2/</id>
    <published>2016-10-17T08:23:55.000Z</published>
    <updated>2018-03-12T16:09:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP、HTTPS、HTTP/2的一些比较 (HTTP/2 虽然从协议角度来说并不一定要基于 TLS 但是浏览器的实现全部是基于 TLS 的，以下所说的 HTTP/2 指浏览器实现的基于 TLS 的版本)。</p><a id="more"></a><h3 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h3><table><thead><tr><th></th><th>HTTP</th><th>HTTPS &amp; HTTP2</th></tr></thead><tbody><tr><td>谷歌</td><td>❌</td><td>✔️</td></tr><tr><td>百度</td><td>❌</td><td>❌ </td></tr></tbody></table><p>HTTPS 对谷歌的 SEO 有微弱加成，百度后续也会有加成</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><table><thead><tr><th></th><th>HTTP</th><th>HTTPS &amp; HTTP/2</th></tr></thead><tbody><tr><td>敏感信息泄露</td><td>❌</td><td>✔️</td></tr><tr><td>DNS 污染</td><td>❌</td><td>✔️</td></tr><tr><td>DNS 劫持</td><td>❌</td><td>✔️</td></tr><tr><td>中间人攻击</td><td>❌</td><td>✔️ (连接建立后)</td></tr></tbody></table><p>HTTPS 和 HTTP/2 的安全性明显优于 HTTP</p><h3 id="计算耗时"><a href="#计算耗时" class="headerlink" title="计算耗时"></a>计算耗时</h3><p>相比于HTTP，HTTPS &amp; HTTP/2 加解密过程中存在额外的计算耗时，特别是首次连接建立的 TLS 握手过程中的非对称加解密 (30ms+)。</p><h3 id="首次请求建立前的-RTT"><a href="#首次请求建立前的-RTT" class="headerlink" title="首次请求建立前的 RTT"></a>首次请求建立前的 RTT</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p> <img src="http://ogovd1xl2.bkt.clouddn.com/http.png" alt="http"><br> 最坏耗时 2 个 RTT：</p><ul><li>域名解析，耗时 1 个 RTT (缓存)</li><li>TCP 三次握手，耗时 1 个 RTT</li></ul><p>一般耗时 1 个 RTT</p><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p> <img src="http://ogovd1xl2.bkt.clouddn.com/https.png" alt="https"><br> 最坏耗时 9 个 RTT：</p><ul><li>域名解析， 耗时 1 个 RTT</li><li>TCP 三次握手，耗时 1 个 RTT</li><li>HTTP 重定向 HTTPS 及后续握手 耗时 2 个 RTT  (开启 <a href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security" target="_blank" rel="noopener">HSTS</a>)<pre><code>* 302 过程，耗时 1 个 RTT* TCP 重新握手，耗时 1 个 RTT</code></pre></li><li>TLS 完全握手过程 耗时 4 个 RTT + 1 个 DNS 解析 <pre><code>* TLS 完全握手 耗时 2 个 RTT * TLS 握手过程中的 CA 域名解析 耗时 1 个 RTT (缓存) * CA 站点 TCP 握手，耗时 1 个 RTT * [OCSP](https://en.wikipedia.org/wiki/    Online_Certificate_Status_Protocol) 查询 耗时 1 个 RTT (缓存)</code></pre></li></ul><p>一般耗时 2 个 RTT</p><h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><p><img src="http://ogovd1xl2.bkt.clouddn.com/how-alpn-works.png" alt="ALPN"><br>HTTP/2 使用 <a href="https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation" target="_blank" rel="noopener">ALPN</a> 在 TLS 握手过程中即可进行, 耗时同 HTTPS</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p><img src="http://ogovd1xl2.bkt.clouddn.com/123.png" alt="compare"> </p><p>HTTP 和 HTTPS 在使用长连接的情况下后续请求延迟相差不大，两者都存在 HOL blocking 问题，每次请求都需要等上一个请求完成，这个过程会造成额外的 RTT。HTTP/1.1 虽然可采用</p><ul><li>内嵌及打包资源以减少HTTP请求</li><li>多连接 (浏览器一般默认每来源 6 个连接，可利用多域名优化突破连接数限制) 减少排队 </li><li>HTTP pipelining </li></ul><p>等优化手段减少 RTT 延迟，但每个方案都不是完美的，如内嵌或打包资源无法使用细粒度的缓存，多连接的方式会对服务端造成相当大的开销，HTTP pipelining 仍然存在 HOL blocking 的问题，且只对幂等的请求有效。</p><p>HTTP/2 使用二进制分帧机制，所有通信在一个 TCP 连接上完成，可以并行交错地发送请求和响应，解决了应用层 HOL 阻塞问题 (TCP 层仍存在 HOL 阻塞)，消除了并行处理和发送请求及响应时对多个连接的依赖，而且其在协议层面的支持，不需要额外的开发。</p><h3 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h3><p>HTTP 的每一次通信都会携带一组首部，用于描述传输的资源及其属性。在 HTTP/1.1 中，这些元数据都是以纯文本形式发送的，重复且过大的首部增加了延迟和带宽开销，严重的情况下，由于 TCP 慢启动的原因，首部长度超过初始拥塞窗口，会增加一次额外的 RTT。</p><p>HTTP/2 采用 HPACK 压缩首部，有效的减少了重复首部字节的流量开销。</p><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>HTTP/1.1 不支持服务器推送。</p><p>HTTP/2 支持服务器推送，服务器可以对一个客户端请求发送多个响应，如此服务器可以分析资源文档，将文档相关连的资源提前推送给客户端，避免了客户端文档分析依赖后，重新请求的开销。</p><p>客户端可以拒绝服务端推送的资源，这可能会造成资源的浪费。目前大部分服务器还不支持服务器推送。</p><h3 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a>请求优先级</h3><p>HTTP/1.1 不支持请求优先级。</p><p>HTTP/2 可以设置请求的优先级，通过优先级设置可以将重要的资源优先发送给客户端，客户端因此可以更快的向用户呈现界面。</p><p>目前大部分服务器还不支持服务器推送</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>HTTP/1.1 不支持流量控制。</p><p>HTTP/2 采用类似 TCP 滑动窗口的机制进行流量控制，可以避免网络拥堵。</p><p>目前大部分服务器还不支持服务器推送</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>绝绝绝大部分情况： HTTP/2 优于 HTTPS </li><li>请求数量多的情况：HTTP/2 优于 HTTP</li><li>对安全性要求高的情况：HTTPS 优于 HTTP</li><li>高 RTT 的情况： HTTP 优于 HTTP/2 </li><li>下载大文件的情况：HTTP 优于 HTTP/2 </li></ul><p>总之如果之前是 HTTP，且要考虑浏览器兼容，对安全传输要求不高，采用过打包，多域名等优化手段的情况，升级 HTTP/2 可能会造成负面的性能问题。除此之外，就愉快的升级 HTTP/2 吧 (特别是主要升级成本在运维大哥的情况下)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP、HTTPS、HTTP/2的一些比较 (HTTP/2 虽然从协议角度来说并不一定要基于 TLS 但是浏览器的实现全部是基于 TLS 的，以下所说的 HTTP/2 指浏览器实现的基于 TLS 的版本)。&lt;/p&gt;
    
    </summary>
    
      <category term="写码" scheme="http://eggggger.xyz/categories/programming/"/>
    
    
      <category term="HTTP2" scheme="http://eggggger.xyz/tags/HTTP2/"/>
    
      <category term="HTTPS" scheme="http://eggggger.xyz/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 2.0 与 NPN 与 ALPN 与 OpenSSL 与 Nginx</title>
    <link href="http://eggggger.xyz/2016/10/16/HTTP2/"/>
    <id>http://eggggger.xyz/2016/10/16/HTTP2/</id>
    <published>2016-10-16T06:40:31.000Z</published>
    <updated>2018-03-13T15:44:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>Chrome build 51 移除了对 NPN 和 SPDY 的支持，这导致大部分基于 NPN 的 HTTP 2.0 服务回落到 HTTP 1.1 版本。在新版及以后的Chrome中只有支持了 ALPN 的 HTTP 2.0 服务才是可用的。</p><a id="more"></a><h3 id="NPN-amp-ALPN"><a href="#NPN-amp-ALPN" class="headerlink" title="NPN &amp; ALPN"></a>NPN &amp; ALPN</h3><p>首先，还是先简单介绍下 NPN 和 ALPN</p><ul><li><p>NPN (Next Protocol Negotiation)<br><img src="http://ogovd1xl2.bkt.clouddn.com/xnpn-negotiation.png.pagespeed.ic.jL_X7qsh4g.png?imageView2/1/w/696/h/348" alt="NPN"><br>NPN 是 Google 在 SPDY 中开发的一个 TLS 扩展。如上图所示，NPN 是利用 TLS 握手中的 ServerHello 消息，在其中追加 ProtocolNameList 字段包含自己支持的应用层协议，客户端检查改字段，并在之后的 ClientKeyExChange (图中的 Certificate Verify) 消息中以 ProtocolName 字段 返回选中的协议。</p></li><li><p>ALPN (Application-Layer Protocol Negotiation)<br><img src="http://ogovd1xl2.bkt.clouddn.com/how-alpn-works.png?imageView2/1/w/696/h/348" alt="ALPN"><br>ALPN 是 IETF 在 NPN 的基础上修订的版本，也是HTTP2的基准。在 ALNP 中，交换次序相对于 NPN 是颠倒的，客户端先声明自己支持的协议 (ClientHello)，服务器选择并确认协议 (ServerHello) 。这样颠倒的目的主要是使 ALPN 与其他协议协商标准保持一致 (如 SSL) 。</p></li></ul><p>服务器和客户端可以在 TLS 握手过程中选择双方所支持的应用层协议进行后续的加密通信，如果不支持任何一种协议则断开通信连接。</p><h3 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h3><p>一般的 Web 服务 (如 Nginx) 都是使用的 OpenSSL，而 OpenSSL 对 ALPN 的支持是在 2015年1月 发布的 1.0.2 版本中加入的。目前主流的操作系统的 OpenSSL 版本情况如下表所示：<br><img src="http://ogovd1xl2.bkt.clouddn.com/wwww.png?imageView2/1/w/1031/h/348" alt="os"><br>想要启用 ALPN 则必需升级版本到 1.0.2 以上，升级命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://www.openssl.org/source/openssl-1.0.2j.tar.gz</span><br><span class="line">$ tar -zxf openssl-1.0.2j.tar.gz -C /usr/local/</span><br><span class="line">$ cd /usr/local/openssl-1.0.2j</span><br><span class="line">$ ./config</span><br><span class="line">$ make</span><br><span class="line">$ make test</span><br><span class="line">$ make install</span><br><span class="line">$ mv /usr/bin/openssl /usr/bin/openssl_1.0.1e</span><br><span class="line">$ ln -s /usr/local/ssl/bin/openssl /usr/bin/openssl</span><br><span class="line">$ openssl version</span><br><span class="line">OpenSSL 1.0.2j  26 Sep 2016</span><br></pre></td></tr></table></figure><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>Nginx 是在 1.9 版本中加入对 HTTP 2.0 的支持的，在 Chrome build 51 后如需要 支持 HTTP 2.0 服务的话，需要重新构建一遍 Nginx</p><p>安装 PCRE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.39.tar.gz</span><br><span class="line">$ tar -zxf pcre-8.39.tar.gz</span><br><span class="line">$ cd pcre-8.39</span><br><span class="line">$ ./configure</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure><p>安装 zlib</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://zlib.net/zlib-1.2.8.tar.gz</span><br><span class="line">$ tar -zxf zlib-1.2.8.tar.gz</span><br><span class="line">$ cd zlib-1.2.8</span><br><span class="line">$ ./configure</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure><p>安装 OpenSSL 同上，安装Nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://nginx.org/download/nginx-1.11.6.tar.gz</span><br><span class="line">$ tar zxf nginx-1.11.6.tar.gz</span><br><span class="line">$ cd nginx-1.11.6</span><br><span class="line">$ ./configure \</span><br><span class="line">    --sbin-path=/usr/local/nginx/nginx \</span><br><span class="line">    --conf-path=/usr/local/nginx/nginx.conf \</span><br><span class="line">    --pid-path=/usr/local/nginx/nginx.pid \</span><br><span class="line">    --lock-path=/var/lock/nginx.lock \</span><br><span class="line">    --error-log-path=/var/log/nginx/error.log \</span><br><span class="line">    --http-log-path=/var/log/nginx/access.log \</span><br><span class="line">    --with-http_ssl_module \</span><br><span class="line">    --with-http_v2_module \</span><br><span class="line">    --with-stream \</span><br><span class="line">    --with-pcre=../pcre-8.39 \</span><br><span class="line">    --with-zlib=../zlib-1.2.8 \</span><br><span class="line">    --with-openssl=../openssl-1.0.2j</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br><span class="line">$ sudo ln -s /usr/local/nginx/nginx /usr/bin</span><br><span class="line">$ nginx version: nginx/1.11.6</span><br></pre></td></tr></table></figure><p>之后就可以通过简单的配置开启 HTTP 2.0 服务了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl http2;</span><br><span class="line"></span><br><span class="line"> # 加解密使用的证书和私钥</span><br><span class="line">    ssl_certificate server.crt;</span><br><span class="line">    ssl_certificate_key server.key;</span><br><span class="line">    </span><br><span class="line">    # 分割的最大响应块大小，过小会加重服务器负荷，过大会造成 HOL 阻塞</span><br><span class="line">    # http2_chunk_size 8k; </span><br><span class="line">    </span><br><span class="line">    # 每个请求的最大缓冲区大小 (请求被处理之前保存在缓冲区)</span><br><span class="line">    # http2_body_preread_size;</span><br><span class="line">    </span><br><span class="line">    # 不活动连接的最大维持时间，超时后关闭连接</span><br><span class="line">    # http2_idle_timeout 3m;</span><br><span class="line">    </span><br><span class="line">    # 同一个连接中传输的最大 HTTP 2.0 流的最大数量</span><br><span class="line">    # http2_max_concurrent_streams 128;</span><br><span class="line">    </span><br><span class="line">    # HPACK 压缩后的最大请求头大小</span><br><span class="line">    # http2_max_field_size</span><br><span class="line">    </span><br><span class="line">    # HPACK 解压后的最大请求头大小</span><br><span class="line">    # http2_max_header_size 16k;</span><br><span class="line">    </span><br><span class="line">    # 单个 HTTP 2.0 连接的最大请求次数 (超过次数后启用一个新的连接) </span><br><span class="line">    # 需要 1.11.6 以上版本</span><br><span class="line">    # http2_max_requests 1000;</span><br><span class="line">    </span><br><span class="line">    # 每个 worker 的最大接收缓冲大小</span><br><span class="line">    # http2_recv_buffer_size 256k;</span><br><span class="line">    </span><br><span class="line">    # 期望从客户端收到更多数据的最大时间，超时后关闭连接</span><br><span class="line">    # http2_recv_timeout 30s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>证书可以在 <a href="https://www.sslforfree.com/" target="_blank" rel="noopener">sslforfree</a> 之类的免费 CA 获得，当然也可以使用 OpenSSL 生成自签名的证书。配置完之后就可以通过 Nginx 愉快的玩耍 HTTP 2.0了🙈。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://www.nginx.com/blog/supporting-http2-google-chrome-users/" target="_blank" rel="noopener">Supporting HTTP/2 for Google Chrome Users</a></li><li><a href="http://nginx.org/en/docs/http/ngx_http_v2_module.html" target="_blank" rel="noopener">Module ngx_http_v2_module</a></li><li><a href="https://www.nginx.com/resources/admin-guide/installing-nginx-open-source/" target="_blank" rel="noopener">nginx version: nginx/1.11.6</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chrome build 51 移除了对 NPN 和 SPDY 的支持，这导致大部分基于 NPN 的 HTTP 2.0 服务回落到 HTTP 1.1 版本。在新版及以后的Chrome中只有支持了 ALPN 的 HTTP 2.0 服务才是可用的。&lt;/p&gt;
    
    </summary>
    
      <category term="写码" scheme="http://eggggger.xyz/categories/programming/"/>
    
    
      <category term="HTTP2" scheme="http://eggggger.xyz/tags/HTTP2/"/>
    
      <category term="NPN" scheme="http://eggggger.xyz/tags/NPN/"/>
    
      <category term="ALPN" scheme="http://eggggger.xyz/tags/ALPN/"/>
    
      <category term="Nginx" scheme="http://eggggger.xyz/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>OpenSearch</title>
    <link href="http://eggggger.xyz/2016/08/10/OpenSearch/"/>
    <id>http://eggggger.xyz/2016/08/10/OpenSearch/</id>
    <published>2016-08-10T15:50:13.000Z</published>
    <updated>2018-03-12T16:24:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>OpenSearch 是 Amazon.com 子公司 A9 所提出的一个用来分享搜索结果的微格式集合，OpenSearch 说明文档可以描述一个搜索引擎，它能被搜索客户端识别（如 Chrome ）。</p><a id="more"></a><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>具体介绍之前，先拿百度举个🌰 </p><p>如下图所示，在 Chrome 的地址栏中输入百度的网址并按下 tab 键就能直接使用百度搜索而无须先打开百度（前提条件：之前访问过百度）</p><p><img src="http://7xqpu6.com1.z0.glb.clouddn.com/baidu.png" alt="baidu"></p><p>那么怎么实现这样的效果呢？</p><hr><p>首先，我们用 Chrome 的检查功能查看百度的源码，可以发现以下这行代码</p><p><img src="http://7xqpu6.com1.z0.glb.clouddn.com/baidu-link.png" alt="baidu link"></p><p>这个 &lt;link&gt; 标签定义了 OpenSearch 文档的引用，其中：</p><ul><li><strong>type</strong> 属性（必须）包含 application/opensearchdescription+xml</li><li><strong>rel</strong> 属性（必须）包含 search</li><li><strong>href</strong> 属性（必须）包含一个指向 OpenSearch 说明文档的 URL</li><li><strong>title</strong> 属性（可选）可以包含一个描述搜索引擎的文本 如 百度搜索</li><li><strong>&lt;head&gt;</strong> 标签 （可选）应该包含一个 profile 属性，其值为 <a href="http://a9.com/-/spec/opensearch/1.1/" target="_blank" rel="noopener">http://a9.com/-/spec/opensearch/1.1/</a></li></ul><hr><p>然后我们再看一下百度这个 OpenSearch 文档的具体内容</p><p><a href="https://www.baidu.com/content-search.xml" target="_blank" rel="noopener"><img src="http://7xqpu6.com1.z0.glb.clouddn.com/baidu-opensearch.png" alt="baidu OpenSearch"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;OpenSearchDescription xmlns=&quot;http://a9.com/-/spec/opensearch/1.1/&quot;&gt;</span><br><span class="line">&lt;ShortName&gt;百度搜索&lt;/ShortName&gt;</span><br><span class="line">&lt;Url type=&quot;text/html&quot; template=&quot;https://www.baidu.com/s?wd=&#123;searchTerms&#125;&quot;/&gt;</span><br><span class="line">&lt;/OpenSearchDescription&gt;</span><br></pre></td></tr></table></figure><p>这个文档包含了 Chrome 所必需的最少的两个字段，其中</p><ul><li><strong>&lt;ShortName&gt;</strong> 元素包含了一个标识搜索引擎的标题（注意长度不能超过16个字符），它会出现在 Chrome 的地址栏里 也就是上图中的百度搜索</li><li><p><strong>&lt;Url&gt;</strong> 元素包含了搜索链接的格式，它告诉客户端如何使用搜索引擎，其中</p><ul><li><p><strong>template</strong> 属性（必须）定义了URL的模板（<a href="#OpenSearch-URL-模板语法">URL 模板语法</a>）</p><ul><li><strong>searchTerms</strong> 将被客户端（如 Chrome）替换为对应的关键词</li><li><strong>count</strong> 将被替换为搜索结果的数量</li><li><strong>startIndex</strong>  将被替换为第一个搜索结果的数量 （默认 indexOffset 属性的值）</li><li><strong>startPage</strong>  将被替换为第一组搜索结果的页码 （默认 pageOffset 属性的值）</li><li><strong>language</strong> 将被替换为期望得到的搜索结果的语言（默认 *）</li><li><strong>inputEncoding</strong> 将被替换为执行搜索时的编码（默认 UTF-8）</li><li><strong>outputEncoding</strong> 将被替换为期望得到的搜索结果的编码（默认 UTF-8）</li></ul></li><li><p><strong>type</strong> 属性（必须） 定义了资源的 MIME type （如 text/html 表明搜索返回的是一个文档，Chrome 会跳转到该文档）</p></li><li><p><strong>rel</strong> 属性（可选）定义了资源和文档的关系</p><ul><li><strong>results</strong> （默认）表示指定格式的搜索结果的请求</li><li><strong>suggestions</strong> 表示指定格式的搜索建议的请求</li><li><strong>self</strong> 表示这个说明文档的规范 URL</li><li><strong>collection</strong> 表示一组资源的请求</li></ul></li><li><p><strong>indexOffset</strong> 属性（可选）定义了第一个搜索结果的起始值（默认为 1）</p></li><li><strong>pageOffset</strong> 属性（可选）定义了第一组搜索结果的页码（默认为 1）</li></ul></li></ul><hr><p>所以，如果你想要你的网站也支持在 Chrome 里按 tab 搜索，只需要在HTML文档里加入一个特定的 <strong>&lt;link&gt;</strong> 标签指向你的OpenSearch XML文档就行了（你的OpenSearch文档里至少要包含 <strong>&lt;ShortName&gt;</strong> 和 <strong>&lt;Url&gt;</strong>）。</p><h2 id="OpenSearch-元素"><a href="#OpenSearch-元素" class="headerlink" title="OpenSearch 元素"></a>OpenSearch 元素</h2><p>OpenSearch 文档中除了上述提到的<strong>&lt;ShortName&gt;</strong>、<strong>&lt;Url&gt;</strong>元素外还有下面这些元素：</p><ul><li><p><strong>&lt;Description&gt;</strong> （必需）包含一段描述搜索引擎的文本（不多于1024个字符）</p></li><li><p><strong>&lt;LongName&gt;</strong>（可选）包含一段标识搜索引擎的文本（少于48个字符）</p></li><li><p>补充中…</p></li></ul><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h5 id="OpenSearch-URL-模板语法"><a href="#OpenSearch-URL-模板语法" class="headerlink" title="OpenSearch URL 模板语法"></a>OpenSearch URL 模板语法</h5><pre><code class="js">ttemplate      = tscheme <span class="string">":"</span> thier-part [ <span class="string">"?"</span> tquery ] [ <span class="string">"#"</span> tfragment ]tscheme        = *( scheme / tparameter )thier-part     = <span class="string">"//"</span> tauthority ( tpath-abempty / tpath-absolute / tpath-rootless / path-empty )tauthority     = [ tuserinfo <span class="string">"@"</span> ] thost [ <span class="string">":"</span> tport ]tuserinfo      = *( userinfo / tparameter )thost          = *( host / tparameter )tport          = *( port / tparameter )tpath-abempty  = *( <span class="string">"/"</span> tsegment )tsegment       = *( segment / tparameter )tpath-absolute = <span class="string">"/"</span> [ tsegment-nz *( <span class="string">"/"</span> tsegment ) ]tsegment-nz    = *( segment-nz / tparameter )tpath-rootless = tsegment-nz *( <span class="string">"/"</span> tsegment )tparameter     = <span class="string">"{"</span> tqname [ tmodifier ] <span class="string">"}"</span>tqname         = [ tprefix <span class="string">":"</span> ] tlnametprefix        = *pchartlname         = *pchartmodifier      = <span class="string">"?"</span>tquery         = *( query / tparameter )tfragement     = *( fragement / tparameter )</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OpenSearch 是 Amazon.com 子公司 A9 所提出的一个用来分享搜索结果的微格式集合，OpenSearch 说明文档可以描述一个搜索引擎，它能被搜索客户端识别（如 Chrome ）。&lt;/p&gt;
    
    </summary>
    
      <category term="写码" scheme="http://eggggger.xyz/categories/programming/"/>
    
    
      <category term="OpenSearch" scheme="http://eggggger.xyz/tags/OpenSearch/"/>
    
  </entry>
  
</feed>
