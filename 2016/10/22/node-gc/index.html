<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>【译】Node.js 垃圾回收 | 写码笔记</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-109825051-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">【译】Node.js 垃圾回收</h1><a id="logo" href="/.">写码笔记</a><p class="description">duqutao@gmail.com</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">【译】Node.js 垃圾回收</h1><div class="post-meta">Oct 22, 2016<span> | </span><span class="category"><a href="/categories/programming/">写码</a></span></div><div class="post-content"><p>在这篇文章中，你可以学到 Node.js 的垃圾回收 (以下简称 GC ) 是怎么工作的，你写下的代码在后台发生了什么，以及内存是如何释放的。</p>
<a id="more"></a>
<center><br><img src="http://ogovd1xl2.bkt.clouddn.com/ancient-garbage-collector-in-action.jpg" alt="ancient-garbage-collector-in-action"><br></center>

<h3 id="Node-js-应用中的内存管理"><a href="#Node-js-应用中的内存管理" class="headerlink" title="Node.js 应用中的内存管理"></a>Node.js 应用中的内存管理</h3><p>每个应用都需要内存才能正常运行。内存管理能动态的分配内存块给需要的程序，在不需要时释放掉，以便能重复使用。</p>
<p>应用级的内存管理可以是手动或自动的。而自动内存管理往往涉及到 GC。</p>
<p>下面的代码片段展示了在 C 中如何使用手动内存管理分配内存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">   char name[20];</span><br><span class="line">   char *description;</span><br><span class="line"></span><br><span class="line">   strcpy(name, &quot;RisingStack&quot;);</span><br><span class="line"></span><br><span class="line">   // memory allocation</span><br><span class="line">   description = malloc( 30 * sizeof(char) );</span><br><span class="line"></span><br><span class="line">   if( description == NULL ) &#123;</span><br><span class="line">      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      strcpy( description, &quot;Trace by RisingStack is an APM.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   printf(&quot;Company name = %s\n&quot;, name );</span><br><span class="line">   printf(&quot;Description: %s\n&quot;, description );</span><br><span class="line"></span><br><span class="line">   // release memory</span><br><span class="line">   free(description);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<strong>手动内存管理</strong>中，开发者有责任释放闲置的内存，这种内存管理方式可能会造成下面几个问题：</p>
<ul>
<li><strong>内存泄露</strong>，当从不释放使用过的内存时发生</li>
<li><strong>野指针</strong>，当对象被释放时，而原来的指针仍继续使用。在其他数据覆盖写入或读取敏感信息时会造成严重的安全问题</li>
</ul>
<p><strong>值得庆幸的是，Node.js 附带了一个垃圾回收器，你不需要去手动管理内存分配</strong></p>
<h3 id="GC-的理念"><a href="#GC-的理念" class="headerlink" title="GC 的理念"></a>GC 的理念</h3><p>GC 是一种自动管理应用内存的方法。GC 的工作是回收被未使用的对象所占用的内存。它在 1959 年首次应用于 John McCarthy 创造的 LISP 中。</p>
<p>GC 判断对象不再使用的方式是没有其他的对象引用它们。</p>
<h6 id="GC-前的内存"><a href="#GC-前的内存" class="headerlink" title="GC 前的内存"></a>GC 前的内存</h6><p>你的内存看上去如下图所示，如果你有一些互相引用的对象以及一些没有任何引用的对象。这些没有引用的对象会在 GC 运行 时被回收。</p>
<center><br><img src="http://ogovd1xl2.bkt.clouddn.com/memory-state-before-node-js-garbage-collection.png" alt="memory-state-before-node-js-garbage-collection"><br></center>

<h6 id="GC-后的内存"><a href="#GC-后的内存" class="headerlink" title="GC 后的内存"></a>GC 后的内存</h6><p>当 GC 运行起来，无法访问 (没有引用) 的对象会被删除，同时释放掉相应的内存空间。</p>
<center><br><img src="http://ogovd1xl2.bkt.clouddn.com/memory-state-after-node-js-garbage-collection.png" alt="memory-state-after-node-js-garbage-collection"><br></center>

<h4 id="GC-的优点"><a href="#GC-的优点" class="headerlink" title="GC 的优点"></a>GC 的优点</h4><ul>
<li>防止了野指针 bug</li>
<li>不用担心内存的二次释放</li>
<li>避免了一些类型的内存泄露</li>
</ul>
<p>当然，使用 GC 不能解决你所有的问题，而且它也不是内存管理的银弹。</p>
<h6 id="使用-GC-时需要注意的事项"><a href="#使用-GC-时需要注意的事项" class="headerlink" title="使用 GC 时需要注意的事项"></a>使用 GC 时需要注意的事项</h6><ul>
<li><strong>性能影响</strong> - GC 会消耗计算能力去决定什么对象应该释放</li>
<li><strong>无法预测的停顿</strong> - 现代 GC 实现尝试去避免 <strong>stop-the-world</strong> 的回收方式</li>
</ul>
<h3 id="Node-js-GC-amp-内存管理实践"><a href="#Node-js-GC-amp-内存管理实践" class="headerlink" title="Node.js GC &amp; 内存管理实践"></a>Node.js GC &amp; 内存管理实践</h3><p>实践出真知，所以我打算通过几段不同的代码向你展示内存中发生了什么</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈上包含了局部变量和指向堆上对象或指向应用程序控制流程的指针。<br>在以下示例中，a和b将会被放置在栈中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add (a, b) &#123;  </span><br><span class="line">  return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(4, 5)</span><br></pre></td></tr></table></figure>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆专门用于存储引用类型对象，如字符串和对象。<br>在以下示例中，Car 对象将会被放置在堆中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Car (opts) &#123;  </span><br><span class="line">  this.name = opts.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const LightningMcQueen = new Car(&#123;name: &apos;Lightning McQueen&apos;&#125;)</span><br></pre></td></tr></table></figure>
<p>在这之后，内存看起来像这个样子</p>
<center><br><img src="http://ogovd1xl2.bkt.clouddn.com/node-js-garbage-collection-first-step-object-placed-in-memory-heap.png" alt="node-js-garbage-collection-first-step-object-placed-in-memory-heap"><br></center>

<p>让我们添加更多的 Car 对象，看看内存会是什么样子！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Car (opts) &#123;  </span><br><span class="line">  this.name = opts.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const LightningMcQueen = new Car(&#123;name: &apos;Lightning McQueen&apos;&#125;)  </span><br><span class="line">const SallyCarrera = new Car(&#123;name: &apos;Sally Carrera&apos;&#125;)  </span><br><span class="line">const Mater = new Car(&#123;name: &apos;Mater&apos;&#125;)</span><br></pre></td></tr></table></figure>
<center><br><img src="http://ogovd1xl2.bkt.clouddn.com/node-js-garbage-collection-second-step-more-elements-added-to-the-heap.png" alt="node-js-garbage-collection-second-step-more-elements-added-to-the-heap"><br></center>

<p>如果GC现在运行，由于根有对每个对象的引用，没有对象会被释放。</p>
<p>让我们添加一些零件到我们的汽车里 (Car 对象) 使它更有趣一点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Engine (power) &#123;  </span><br><span class="line">  this.power = power</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Car (opts) &#123;  </span><br><span class="line">  this.name = opts.name</span><br><span class="line">  this.engine = new Engine(opts.power)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let LightningMcQueen = new Car(&#123;name: &apos;Lightning McQueen&apos;, power: 900&#125;)  </span><br><span class="line">let SallyCarrera = new Car(&#123;name: &apos;Sally Carrera&apos;, power: 500&#125;)  </span><br><span class="line">let Mater = new Car(&#123;name: &apos;Mater&apos;, power: 100&#125;)</span><br></pre></td></tr></table></figure>
<center><br><img src="http://ogovd1xl2.bkt.clouddn.com/node-js-garbage-collection-assigning-values-to-the-objects-in-heap.png" alt="node-js-garbage-collection-assigning-values-to-the-objects-in-heap"><br></center>

<p>如果我们不再使用 Mater，但是重新定义并对它赋值 (如Mater = undefined) 会发生什么？</p>
<center><br><img src="http://ogovd1xl2.bkt.clouddn.com/node-js-garbage-collection-redefining-values.png" alt="node-js-garbage-collection-redefining-values"><br></center>

<p>结果就是，无法从根上访问 Master 对象。所以当下一次 GC 运行时，它将会被释放：</p>
<center><br><img src="http://ogovd1xl2.bkt.clouddn.com/node-js-garbage-collection-freeing-up-unreachable-object.png" alt="node-js-garbage-collection-freeing-up-unreachable-object"><br></center>

<p>现在我们了解了 GC 预期行为的基础，那让我们看看它在 V8 中是如何实现的。</p>
<h4 id="GC-方法"><a href="#GC-方法" class="headerlink" title="GC 方法"></a>GC 方法</h4><p>在我们之前的一篇文章中，我们讨论了 <a href="https://blog.risingstack.com/finding-a-memory-leak-in-node-js/" target="_blank" rel="noopener">Node.js GC 方法是如何工作的</a>，所以我强烈建议去阅读这篇文章。</p>
<ul>
<li>新生区和老生区</li>
<li>新生代 (Young Generation)</li>
<li>Scavenge 和 标记删除</li>
</ul>
<h3 id="一个真实的例子-—-The-Meteor-Case-Study"><a href="#一个真实的例子-—-The-Meteor-Case-Study" class="headerlink" title="一个真实的例子 — The Meteor Case-Study"></a>一个真实的例子 — The Meteor Case-Study</h3><p>在 2013 年，Meteor 的作者宣布了他们碰到的关于内存泄露的发现，问题代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var theThing = null  </span><br><span class="line">var replaceThing = function () &#123;  </span><br><span class="line">  var originalThing = theThing</span><br><span class="line">  var unused = function () &#123;</span><br><span class="line">    if (originalThing)</span><br><span class="line">      console.log(&quot;hi&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  theThing = &#123;</span><br><span class="line">    longStr: new Array(1000000).join(&apos;*&apos;),</span><br><span class="line">    someMethod: function () &#123;</span><br><span class="line">      console.log(someMessage)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">setInterval(replaceThing, 1000)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Well, the typical way that closures are implemented is that every function object has a link to a dictionary-style object representing its lexical scope. If both functions defined inside replaceThing actually used originalThing, it would be important that they both get the same object, even if originalThing gets assigned to over and over, so both functions share the same lexical environment. Now, Chrome’s V8 JavaScript engine is apparently smart enough to keep variables out of the lexical environment if they aren’t used by any closures - from the <a href="http://info.meteor.com/blog/an-interesting-kind-of-javascript-memory-leak" target="_blank" rel="noopener">Meteor blog</a>.</p>
</blockquote>
<h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><p><a href="https://blog.risingstack.com/node-js-at-scale-node-js-garbage-collection/?utm_source=nodeweekly&amp;utm_medium=email" target="_blank" rel="noopener">Node.js at Scale - Node.js Garbage Collection Explained</a></p>
</div><div class="tags"><a href="/tags/Node/">Node</a><a href="/tags/GC/">GC</a></div><div class="post-nav"><a class="pre" href="/2016/12/12/things-to-learn-about-linux/">【译】你应该要知道的 Linux 知识 - Julia Evans</a><a class="next" href="/2016/10/17/why-http2/">Why HTTP/2 ?</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'eggggger',
  repo: 'eggggger.github.io',
  oauth: {
    client_id: 'd211383bad9b1b0bfc87',
    client_secret: 'eea964605f5199d9ef1afc6944088b6c40ca647e',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://eggggger.xyz"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/programming/">写码</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/HTTP2/" style="font-size: 15px;">HTTP2</a> <a href="/tags/NPN/" style="font-size: 15px;">NPN</a> <a href="/tags/ALPN/" style="font-size: 15px;">ALPN</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/OpenSearch/" style="font-size: 15px;">OpenSearch</a> <a href="/tags/Node/" style="font-size: 15px;">Node</a> <a href="/tags/GC/" style="font-size: 15px;">GC</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/HTTPS/" style="font-size: 15px;">HTTPS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/11/19/nodebestpractices/">【译】Node.js Best Practices</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/04/restful-api/">【译】RESTful APIs, 一个巨大的谎言</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/12/things-to-learn-about-linux/">【译】你应该要知道的 Linux 知识 - Julia Evans</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/22/node-gc/">【译】Node.js 垃圾回收</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/17/why-http2/">Why HTTP/2 ?</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/16/HTTP2/">HTTP 2.0 与 NPN 与 ALPN 与 OpenSSL 与 Nginx</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/10/OpenSearch/">OpenSearch</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/eggggger" title="github" target="_blank">github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">写码笔记.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>